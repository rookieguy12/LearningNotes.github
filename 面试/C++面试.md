# C++面试

## [杂项]
#### 1. define，const，enum，inline的区别

1. 编译器的处理方式不同

   define在预处理阶段对定义的常量进行替换展开

   const在编译运行阶段使用

   enum在程序运行时起作用

2. 分配内存不同

   define不分配内存，只进行替换展开。

   const常量会分配内存，在堆或者栈

   enum则把内存分配在静态存储区

3. 类型检查方面

   define无类型检查和安全检查，会导致边际效应，出现不可预知的错误。

   const在编译阶段进行类型检查和安全检查

   enum在编译阶和运行阶段段类型检查，但只能进行整形的定义

   inline进行参数类型的安全检查

一般都不使用宏，对于变量，一般是使用enum和const来替换它。对于形似函数的宏定义，则是使用inline替换。



#### 2. C++面向对象三大特点

+ 封装
  + 封装就是指把对象的全部数据和全部方法结合在一起形成一个不可分割的独立单位。
  + 好处：用户只能见到对象封装界面上的信息，对象内部对用户是隐蔽的。
+ 继承
  + 子类继承父类的数据成员和方法
  + 好处：提高复用性
+ 多态
  + 多态性是指在基类中定义的属性或服务被派生类继承后，可以具有不同的数据类型或表现出不同的行为。
  + 好处：提高复用性

#### 3. 静态多态和动态多态

+ 动态多态/运行时多态
  + 动态多态是指以虚函数为依托的**运行时多态**，基类的虚函数由派生的子类重写，通过指向**基类的指针/引用**实现多态。
  + 动态多态本质上就是**面向对象设计**中的继承、多态的概念。动态多态中的接口是显式接口（虚函数），主要也是用在面向对象编程。
  + 优点：
    + 便于处理异质对象
  + 缺点：
    + 运行期间通过虚函数绑定，提高了开销。且编译器无法对其优化
    + 类继承层次庞大，对类的修改影响继承层次
+ 静态多态/编译期多态
  + 静态多态就是**各个类实现相同的函数接口**，这些个接口是隐式接口，即没有继承而是都在内部有相同的函数声明。而**操作这些对象的函数被定义成模板函数**，通过传入不同的模板类，实现静态多态。
  + **模板编程及泛型编程**中，是以**隐式接口和编译器**多态来实现静态多态
  + 优点：
    + 带来了泛型编程和STL
    + 编译期完成多态，提高了效率
    + 具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。
  + 缺点：
    + 可读性降低，调试也困难
    + 无法实现模板的分离编译，工程量大时，编译时间也长
    + 无法处理异质对象集合，这类似于重载函数在编译期进行推导，以确定哪一个函数被调用。

#### 4. 显式接口和隐式接口

+ 显式接口是指在类继承层次中定义的接口，在动态多态中的接口是显式接口。

  通常显示接口由**函数的签名(也就是函数名称、参数类型、返回类型)构成**

+ 隐式接口是静态多态的一个概念。操作静态多态的类的函数往往定义成模板函数，而该模板函数往往要求传入的模板类必须实现某些功能/接口，这些功能和接口在模板函数执行操作的表达式里面可以观察到，这些在模板函数内对模板实参的类所要求必须支持的接口就是隐式接口。

  **因此，它并不基于函数签名式，而是由有效表达式组成。**

#### 5. 右值引用和转移语义

+ 什么是右值、左值？移动/转移语义是什么？

  + 右值左值：

    而实际上，左值就是对应一个变量的存储位置；右值则是对应的值本身。

+ 移动语义

  + 移动语义基于资源转移而不是资源拷贝。目的是将资源从一个对象转移到另一个对象。减少不必要的复制，销毁，提高数据的利用率。
  + 通过提供右值引用的函数，实现移动语义，比如移动构造，移动赋值。对于有指针成员的对象，而又存在使用右值进行构造的情况时，能够减少拷贝，节省资源。

#### 6. C++11新特性

+ auto自动类型推断
+ lambda表达式
+ 智能指针
+ 可变模板参数
+ 左值引用右值引用，移动语义，完美转发

## [C++的多泛型编程范式]

+ C++既是面向过程范式，也是面向对象范式，也可函数式编程范式，也可元数据编程范式，也可泛型编程范式。

## [指针、引用]

#### 1. 指针和引用的联系和区别

1. 指针可以为空，引用也行。
2. 指针可以不初始化，但引用必须初始化
3. 指针可以随时改变指向的目标，但引用不行

#### 2. 系统如何知道指针越界？

1. VC下有一个结构体_CrtMemBlockHeader，里面有一个Gap属性，这个Gap数组放在你的指针数据的后面，默认为0xFD，当检测到你的数据后不是0xFD的时候就说明的你的数据越界了

#### 3. 简述C++中智能指针的特点

+ 常规指针的问题在于**它不是一个对象**，因此，在对象过期时，必须显式地进行delete或delete[]操作。

+ 智能指针，则是一个对象，它可以在生命周期结束时，利用自动调用析构函数的特点，在析构函数内使用delete，就能释放相关内存

+ 智能指针能像普通的指针一样使用，归根结底是因为运算符重载

+ 智能指针分类
  + auto_ptr(最早的，也被淘汰了)
    + 和unique_ptr一样，基于所有权概念，但不及unique_ptr
    + 没有auto_ptr<T []>
    
  + shared_ptr
    + 使用引用计数，每次赋值，计数+1，过期，则减1，最后一个指针过期的时候，才delete
    + 没有shared_ptr<T []>
    + 如果要实现这样一个类，则需要涉及引用计数count，当然count不应该存在于shared_ptr内，而可以另外构造这样一个对象
    
    ```c++
    class Counter {
        friend class SmartPointPro;
    public:
        Counter(){
            ptr = NULL;
            cnt = 0;
        }
        Counter(Object* p){
            ptr = p;
            cnt = 1;
        }
        ~Counter(){
            delete ptr;
        }
    
    private:
        Object* ptr;
        int cnt;
    };
    
    class SmartPointPro {
    public:
        SmartPointerPro(Object* p){
            ptr_counter = new Counter(p);
        }
        SmartPointerPro(const SmartPointerPro &sp){
            ptr_counter = sp.ptr_counter;
            ++ptr_counter->cnt;
        }
        SmartPointerPro& operator=(const SmartPointerPro &sp){
            ++sp.ptr_counter->cnt;
            --ptr_counter.cnt;
            if(ptr_counter.cnt == 0)
                delete ptr_counter;
            ptr_counter = sp.ptr_counter;
        }
        ~SmartPointerPro(){
            --ptr_counter->cnt;
            if(ptr_counter.cnt == 0)
                delete ptr_counter;
        }
    private:
        Counter *ptr_counter;
    };
    
    ```
    
    
    
  + unique_ptr
    + 基于所有权概念，即进行智能指针赋值时，所有权转移，只有一个指针能获得访问权限。
    + 与auto_ptr不同的是
      + auto_ptr允许你将指针赋值到另一个，并将所有权转移，原来的就变成了悬挂指针。
      + 而且auto_ptr不能与new []一起用
    + unique_ptr则是
      + 在编译时检测赋值行为，如果发现是在将左值赋值过来，就会报错，不允许进行赋值；右值倒是没事。如果硬要赋左值，则需要使用move，它就会调用移动构造函数进行赋值了。
      + 有unique_ptr<T []>

#### 4. 简述new和malloc的区别

+ new与delete是关键字，而malloc/free是函数
+ new操作无须指定内存块的大小，malloc则要显式地指出size
+ new返回对应类型指针，而malloc返回void *
+ new分配失败抛出异常，malloc则返回NULL
+ 对自定义类型，new会调用operator new函数，分配空间，低层用malloc实现，然后调用构造函数，初始化成员变量，返回对应指针。delete则先调用析构，再调用operator delete，底层用的free；malloc和free则无法强制调用构造函数和析构函数
+ new/delete允许重载；malloc不行
+ new可以通过定位new在栈上分配内存，当然也可以在堆上分配；malloc则只能在堆上分配

#### 5. palcement_new

```c++
#include <new>
p1 = new (buffer) char[10];
```

+ 定位new不能用delete删除，delete只能删除常规的new分配的堆内存；因此，如果使用定位new在某个区域创建对象了，要让它消除，只能显式地调用析构函数，而且还得注意调用顺序，早创建的晚析构，防止出现依赖缺失的问题

## [编译器优化策略]
#### 1. C++编译器常见的优化

1. 常量替换：

   int a = 2； int b = a； return b；优化成return 2

2. 无用代码消除。若返回值与参数与之无关，则直接优化掉。

3. RVO和NRVO：

   RVO：return value optimization，返回值优化

## [模板]

#### 1. C++模板的几个类型

```c++
template <typename T1, typename T2>
void Print(T1 x,T2 y)
{
    cout << x;
    cout << y;
}

template <typename T>
T add(T x, T y)
{
    return x + y;
}

//模板的显示具体化
template<> add<int>(int x, int y)
{
    return x + y;
}

//模板的部分具体化
template <typename T2>
void Print<int>(int x,T2 y)
{
    cout << x;
    cout << y;
}

//非类型模板参数必须是整形类数据（bool、char、int、long、long long，enum）或者指向外部链接对象的指针
template <typename T,int num=10>
int func(T x,T y)
{
    return x*y*num;
}

//默认模板参数
template<typename T=int> void testTemplateFunc(T param)
{
	cout<<"TemplateFunc's param="<<param<<endl;
}
//类的成员模板
class X
{
   template <class T> void mf(T* t) {}
};
```

## [内存管理]
#### 1. 构造函数、复制构造、赋值运算符、析构函数。
+ 构造函数
  + 构造函数不能定义成虚函数，因为虚函数是按照虚函数表进行调用的，但还没构造，连虚函数表都没有，就无从谈起虚函数了。 
  + 如果有基类，先调用基类构造，再调用自己的构造
  + 构造函数分成默认构造函数、自定义的构造函数、复制构造、移动构造
    + 默认构造函数
      1. 没有参数
      2. 如果没有显式定义构造函数，则会自动生成之。否则得自己加
    + 自定义构造函数
    + 复制构造函数
      1. 参数是const classType&
      2. 如果自己没定义，会自动生成一个浅拷贝版本
    + 移动构造函数
      1. 对于临时对象，在利用它进行对象复制时调用
      2. 一般地，对于含有指针内容的类，在移动构造函数会把指针进行移交
+ 赋值运算符重载
  + 当类本身未被构造时，使用＝会调用复制构造函数
  + 仅当类本身已经构造了，再使用＝才会调用赋值运算
+ 析构函数
  + 析构函数
    + 一个类仅有一个构造函数，没显式定义则有自动生成的，不会释放指针
    + 可以是虚函数
    + 在程序结束进行释放时，在同一个语块内，先定义的后释放。
    + 如果有基类，则先调用自己的析构，再调用基类析构
#### 2. 类的大小计算与内存对齐
**空类占一个字节，不为空这个字节就不算了**。空类的一个字节是为了区分不同类的，因为实例化的时候必须得给它分配内存，最少一个字节，所以就加上一个字节的占位

**对于继承了空类的，会有空类字节优化，不再计算父类大小**

**static成员变量，类方法不占类的内存**

**类的局部数据成员按内存对齐原则计算**

**如果有虚函数，则加上虚函数表的指针大小**

**如果是继承的子类，则加上父类数据成员大小**

**如果该子类是多继承，则虚函数表的指针有多个**

**内存对齐：**

+ 结构体第一个成员的**偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。一般默认是pragma pack()，会挑数据成员里size最大的。对于结构体成员，它的对齐按照结构体内最大的size。

+ **结构体的总大小**为 有效对齐值和最大的成员的size中较小值 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。

#### 3. 内存分配布局

+ C++主要分为栈、堆、静态区/全局区、常量区、代码区
  + 栈：存放局部变量、函数参数、返回数据、返回地址等
  + 堆：一般存放动态内存分配的东西。malloc/free开辟的内存一般在这，普通的new分配的内存也在这
  + 自由存储区：自由存储区是new/delete分配的地方，当然一般也在堆区内
  + 静态区：分为初始化全局区(data)和未初始化全局区(bss)
  + 常量区：存放常量字符串
  + 代码区：存放二进制代码

![](pictures/1.png)

+ 堆和栈的区别
  + 管理方式不同：栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；
  + 空间大小不同：栈的空间是有限的，在32位平台下，堆往往可分配空间更大。
  + 能否产生碎片：栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，如果不停地调用malloc、free对造成内存碎片很多；
  + 生长方向不同：堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。
  + 分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。
  + 分配效率不同：栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。
+ new与malloc
  + 不少new的实现是使用malloc
  + 区别：

![](pictures/2.png)

+ 静态全局变量和全局变量
  + 都在静态区。都会有默认值
  + 静态的只在本文件生效。全局则在别的也可调用。这也意味着在别的文件不能定义与全局变量相同的变量名。

## [函数多态]

#### 1. 虚函数与虚函数表

+ 如果一个类包含虚函数，则会在类最前面分配一个4字节的虚函数表指针（32位系统），指向一个虚函数表。虚函数表指针在对象创建时生成。
+ 虚函数表的每个项代表一个虚函数的地址。虚函数表编译期生成。

+ 对于子类，其虚函数表会将父类虚函数表照搬过来，然后在后面按顺序加上自己新定义的虚函数地址，如果有重写父类虚函数，就把重写的覆盖掉父类的对应函数地址。

+ 如果子类是多继承，则会有多个虚函数指针和多个虚函数表。自己新定义的虚函数会接在第一个虚函数表后面。

+ 动态联编实际上是利用偏移地址决定使用哪个函数的，在多继承时，以指针为例，此处把Base2\*强制赋值给Base1\*，调用时发现Base1->X1()调用了Base2->X2()。

  ```c++
  class Base1
  {
  public:
      virtual void X1(){cout << "X1\n";}
  };
  
  class Base2
  {
  public:
      virtual void X2()
      {
          cout << "X2\n";
      }
  };
  
  class Child : public Base1,public Base2
  {
  };
  int main()
  {
      Child b;
      Base1* ptr1 = &b;
      Base2* ptr2 = &b;
      ptr1 = (Base1*) ptr2;
      ptr1->X1();
      system("pause");
  }
  //这里输出结果是X2
  ```


## [STL]

#### 1. 常用的STL的数据结构

+ vector
+ array
+ list
+ deque
+ stack
+ queue
+ priority_queue
+ set / multiset
+ map / multimap
+ unordered_map
+ unoredered_set

#### 2. map由什么实现的？你知道红黑树和AVL树有什么区别吗？为什么像map，set都用红黑树来实现？你有听过skip-list吗？

+ map是由红黑树实现的
+ 区别：
  + 调整平衡的机制不同
  + 红黑树的插入删除效率更高
  + 红黑树的统计性能比AVL树更高
  + AVL的查找效率更高

#### 3. 用过vector.reserve()吗，vector的数组是怎么增长的？

+ 是两倍两倍增长的，但容量不够的时候，会分配原来容量的两倍大小的空间，然后将原来空间的数据搬移过去
+ 实际上看vector的源代码可以发现，在它继承的_vector_base里面定义了一个struct，它就保存了三个指针，start开始位置，finish，存储元素部分的结束位置，还有end_of_storage，表示capacity的结束位置

#### 4. STL vector插入左值，右值还有析构的区别

