# C++11 新特性

## 一. Variadic Templates可变模板参数

```c++
1. 一个是函数模板上的应用
1.1 例子1
template<typename T, typename... Types>
void Print(const T& firstArg, const Types&... args)
{
    cout << firstArg;
    Print(args...);
}

1.2 例子2——万能哈希
// 1.可以传入任意个参数的一个接口，这玩意一般就是调用的入口，也是具体化程度最低的
template<typename... Types>
inline size_t hash_val(const Types& ... args)
{
    size_t seed = 0;
    hash_val(seed, args...);//接着调用2
    return seed;
}

// 2.这里是一个包含三个部分参数的接口，具体化程度高，用于递归，一个个处理val，让args逐步减少
template<typename T, typename ... Types>
inline void hash_val(size_t& seed, const T& val, const Types& ... args)
{
    hash_combine(seed, val);//每次都处理一个val，将其结果与已有的seed作一个操作
    hash_val(seed, args...);
}

// 3.最后是落到这个函数，说明只有一个val了，会由2跳到这里，最后完成hash
template<typename T>
inline void hash_val(size_t& seed, const T& val)
{
    hash_combine(seed, val);
}

template<typename T>
inline void hash_combine(size_t& seed, const T& val)
{
    seed ^= hash<T>()(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
```

+ 一般地，在使用时就可能需要这种递归的形式；最后还会为边界条件设置一个特化的模板，这一般就是只有0个参数的情况。因为可变模板参数可指向0个参数。当然也可以设为只有1个参数的情况

+ 如果要得到可变模板参数的size，可以使用如下形式

  > sizeof...(args)

```c
2. 另一个是类模板的应用
2.1——tuple类的结构
// tuple类
/*
tuple类实际继承一个_Tuple_impl类，作为桥接和实现的一个类。
*/
// 基本的类声明
template<typename... _Elements>
class tuple;
// 1. 无参版本，作为一个具体化
template<>
class tuple<>{};
    
// 2. 部分具体化的两个参数版，主要是涉及了从一个pair完成的构造
template<typename _T1, typename _T2>
class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>{};

// 3. 泛型的版本
template<typename... _Elements>
class tuple : public _Tuple_impl<0, _Elements...>{}


// _Tuple_impl结构体，里面还有一个_Head_base，里面存放了类型为_Head的一个数据
// 1. 泛型版本
template<std::size_t _Idx, typename _Head, typename... _Tail>
struct _Tuple_impl<_Idx, _Head, _Tail...> : public _Tuple_impl<_Idx + 1, _Tail...>,private _Head_base<_Idx, _Head>{}//我们看到这里就发现有个不断递归继承的一个关系，说明tuple类仅实现一些用户接口，低层的功能结构由_Tuple_impl的一个继承结构完成，每个_Tuple_impl则是由一个Head_Base和其它的_Tail...组成

// 2. 具体化
template<std::size_t _Idx, typename _Head>//最后的最后，会继承到这个结构体，最终就完成这样一个串接
struct _Tuple_impl<_Idx, _Head> : private _Head_base<_Idx, _Head>{}
```

## 二. Spaces in Template Expressions模板参数的空格

+ 就是vector<vector\<int>>里最右边的>>，以前必须要空开，到了C++11就不用空开了

## 三. nullptr && std::nullptr_t

+ C++11使用nullptr而不是NULL
+ 起因是函数的重载，如果既有f(int)，又有f(void *)，那么在传入0和NULL时，都会调用到f(int)；而现在使用nullptr来替代NULL，就可以调用到f(void *)

## 四. auto自动类型推断

```c++
auto x = 42;
auto y = [](int x){return x == 10;};
auto iter = find(c.begin(), c.end(), target);
```

+ 这主要用于类型表达过长时的简化。

## 五. Uniform Initialization列表初始化

```c++
1. C++11以前
以前根据不同，各自通过()，{}初始化。其中{}只能对普通的数组和plain old data进行初始化
2. C++11以后
可以统一用{}赋值

vector<int> a{1,2,3};
complex<double> c{4.0,5.0};
int i{};
int *p{};//设置了初值，int为0，指针为nullptr

struct example{
    int a;
    int b;
};//像这种pod的，其实也可以使用列表初始化
```

+ 原理：编译器看到{a,b,c}，就生成一个initializer_list\<T>，它关联到一个array\<T, n>，接着再调用函数，比如构造函数，赋值函数，将这个array内的元素一个个分解，并传给函数参数。而如果某个对象定义了接收initializer_list\<T>为参数的构造函数或者赋值函数，那么，就不会调用拆分的版本，而是直接调用接收initializer_list\<T>的函数。
+ 需要注意的是，STL内的所有容器，都有一个接收initializer_list\<T>的构造，赋值函数

### 5.1 Initializer_list实现

```c++
/// initializer_list
  template<class _E>
    class initializer_list
    {
    public:
      typedef _E 		value_type;
      typedef const _E& 	reference;
      typedef const _E& 	const_reference;
      typedef size_t 		size_type;
      typedef const _E* 	iterator;
      typedef const _E* 	const_iterator;

    private:
      iterator			_M_array;
      size_type			_M_len;

      // 编译器会调用这个private的构造函数，但注意，这里是浅拷贝
      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }

      // Number of elements.
      constexpr size_type
      size() const noexcept { return _M_len; }

      // First element.
      constexpr const_iterator
      begin() const noexcept { return _M_array; }

      // One past the last element.
      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };

  /**
   *  @brief  Return an iterator pointing to the first element of
   *          the initializer_list.
   *  @param  __ils  Initializer list.
   */
  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }

  /**
   *  @brief  Return an iterator pointing to one past the last element
   *          of the initializer_list.
   *  @param  __ils  Initializer list.
   */
  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
```

## 六. 基于范围的for循环

```c++
for (auto x : {1,2,3})
{
    cout << x;
}
for (const C&elem : x)	//要求对应的构造函数是非explicit的
{
    ...
}
```

+ 编译器对该语句的解释就是变成迭代器的形式

## 七. =default, =delete

+ default可以让编译器重新生成对应的无参构造，复制构造，赋值函数，析构函数，移动构造，移动赋值等，使用那个默认的。
+ delete则表示不要这个函数。常可用于singleton单例，禁止拷贝构造和拷贝赋值。
+ 注意使用范围，default只能用于编译会帮忙默认生成的那些函数，比如构造，赋值，析构；而delete可以用于所有函数

## 八. Alias Template模板别名

```c++
template<typename T>
using Vec = std::vector<T, MyAlloc<T>>;

Vec<int> coll;
// 上面这种别名是using特有的，使用define或者typedef都没法达到这样的效果;using能够进行模板的别名命名
```

+ 需要注意的是，打算进行特化或者偏特化时，是不能对别名进行特化偏特化的，得回到原来的那个进行特化或者偏特化。

```c++
// 例如打算写一个测试程序，将传入的容器类型和value类型结合形成一个容器进行测试。如何创建这个容器呢？
template<typename Container, typename T>
void test(Container c, T val)
{
    // 1. Container<T> container;
    	//报错，编译器无法确定它是一个模板
    // 2. typename Container<T> container;
    	//报错，编译器的typename后面必须加::
}

    // 3. 换其它接口，直接传然后再通过萃取重新创建
template<typename Container>
void test(Container container);
{
    typedef typename iterator_traits<typename Container::iterator>::value_type ValueType;
}


    // 4. 如果没法依靠萃取机制，或者硬要使用原来那种形式？
template<typename T, template<class> class Container>//模板参数模板
```

## 九. Type Alias类型别名

```c++
typedef void (*func)(int, int);

using func = void (*)(int, int);
```

+ 附：

  + using的一些使用方式

    + 表示使用命名空间或者某个命名空间的成员

      ```c++
      using namespace std;
      using std::cout;
      ```

    + 使用类的成员

    + 上面的type alias还有alias template

## 十. noexcept

+ 表示不会抛出异常

```c++
void foo() noexcept;
void foo() noexcept(...);//...为true才不抛异常
void swap(Type& x, Type& y) noexcept(noexcept(x.swap(y)));//表示x.swap(y)不抛异常的话它就不抛异常
```

+ 通常地，vector在重新分配内存空间时，会根据移动构造函数是否加了noexcept来判断能否安全调用移动构造函数。如果可以，它就不调用复制构造，直接调用移动构造了。deque也是如此
+ 所以，写移动构造和移动赋值函数，注意不要让它们抛出异常

## 十一. override

+ 表示override父类的虚函数

```c++
struct Base{
    virtual void func(int);
}

struct Derived : Base{
	virtual void func(int) override;
}
```

+ 主要是在编译时提示你重写了虚函数，如果写成了重载，就会提示你这个不是重写父类虚函数

## 十二. final

+ 表示这个类或者虚函数不会再被继承或重写

```c++
struct finalStruct finale{
    
};
struct Base2{
    virtual void f() final;
}
```

## 十三. decltype

+ 即declare type。获得某个表达式的声明类型

+ 主要应用
  + 声明返回类型
    + 例如声明返回值不确定的函数

    + ```c++
      template<typename T1, typename T2>
      auto add(T1 x, T2 y)->decltype(x + y);
      ```

  + 用于元编程

    + 啥是模板元编程呢？模板的一个特点就是在编译时编译器会分析你的代码，从而实例化具体会用到的模板类型，而不会把模板本身进行编译。模板元编程，就是指程序在编译时，实例化代码的这个编程方式。例如使用模板来完成递归

    + ```c++
      template<int N>
      struct fab
      {
          enum {Result = fab<N-1>::Result + fab<N-2>::Result};
      };
      
      template<>
      struct fab<1>
      {
          enum {Result = 1};
      };
      
      template<>
      struct fab<0>
      {
          enum {Result = 0};
      };
      // 在使用这种结构时，编译程序总是实例化你要用到的模板的具体实例，而由于采取了汇编的结构，就会递归地进行实例化。比如求了fab<10>，编译器会把fab<0>到fab<10>的函数全部生成出来。
      ```

    + ```c++
      // 一般的模板，获取某个对象的类型可以直接靠模板参数
      template<typename T>
      void test(T object)
      {
          typedef typename T::
      }
      
      // 而如果某个时间点得到了一个容器，你不知道它的类型，但你想得到它的迭代器类型，则可以通过如下方式获得类型
      typedef typename decltype(object)::iterator iter_type;
      ```

  + 用于传递lambda表达式的类型

    + ```c++
      auto cmp = [](const Person& p1){
          cout << p1.getName();
      };
      set<Person, decltype(cmp)> collection(cmp);
      //这就有点类似typeof
      //注意lambda写了decltype传入后，还要传入cmp参数，否则set会调用默认构造函数，在set的默认构造函数实现中，会调用Compare的默认构造函数生成比较的仿函数，而lambda并没有默认构造函数，也没有赋值运算符重载，导致出错
      
      // 因为lambda的类型在定义lambda表达式的时候是未知的，而要得知它的类型或者用该类型声明一个变量，要么使用模板，要么decltype。
      
      //模板的，大体就是通过函数模板得到类型，再辅助产生一个模板仿函数class
      template<typename T>
      class TypeObject
      {
          T m;
      public:
          TypeObject(T object) : m(std::move(object)){};
          bool operator()()
          {
              return bool(m());
          }
      };
      
      template<typename T>
      TypeObject<T> getType(T object)
      {
          return TypeObject<T>(object);
      }
      ```

## 十四. lambda

+ 声明出来的lambda，就像是仿函数和普通函数一样
+ 就像一个inline function一样，inline在函数定义前面，建议了编译器的代码生成，减少栈的消耗

```c++
auto i = []{//无参数可以省略()
    cout << "lambda";
};

i();

[...](...) mutable throwSepc -> returnType{...};
// mutable表示会对[...]进行修改，如果里面修改了值传递的变量，就必须加mutable，不加，则值传递的变量为readonly
// throwSpec表示异常的位置，比如写了noexcept
```

