# Unity的值类型和引用类型 #

## 一、值类型和引用类型 ##

+ 值类型：

  + 在声明后，无论是否赋值，编译器均在为其分配内存。

  + 值类型直接存储其值

  + 主要包括基本的数据类型以及结构体struct,枚举，可空类型等。这些类型都隐式派生自System.ValueType，ValueType是System.Object的子类

    int i = 0；与 int i = new int()等价

  + 值类型的实例通常是在线程栈上分配的(静态分配)，注意是通常，不是总是。见详解的嵌套

  + 值类型的变量赋值时复制其包含的值。

+ 引用类型：

  + 在声明后，只在栈中分配容纳地址的内存。当new一个实例时，才在堆上分配存储空间。

  + 引用类型存储对值的引用

  + 主要包括数组，类(class)，接口(interface)，委托(delegate)，字符串string，Object，Dynamic等。

    ```c#
    string s1 = "a" ;
    string s2 = s1 ;
    s1 = "b";	//s2 is still "a"
    ```

    虽然string是引用类型，但是赋值运算被重载了，使得它看起来像值类型罢了。

  + 引用类型的对象总是在进程堆中分配(动态分配)

  + 引用类型的变量赋值时只赋值对象的引用，而不复制对象本身。

## 二、详解 ##

+ 数组

  ```c#
  TestType[] testTypes = new TestType[100];
  ```

  1. 若TestType是值类型，则会在托管堆上分配100个值类型的存储空间，并自动初始化，将这些元素存储过去。

  2. 若TestType是引用类型，也会在托管堆中分配空间，但全都是null，不进行初始化，这些空间是用来存放引用的，当使用testTypes[i] = new TestType()时，才分配TestType空间，修改引用testTypes[i]

+ 类型嵌套问题

  + 这是指引用类型中包含值类型、或是值类型中包含了引用类型的情况
  + 处理原则：
    + 引用类型总是分配在托管堆上
    + 值类型总是分配在声明的地方：作为字段时，跟着所属的实例存储，实例是引用类型，就在托管堆上，实例是局部变量，就在栈上。

## 三、区别 ##

+ 引用类型可以派生出新类型，值类型不行，因为都是seal的
+ 引用类型可以包含null，值类型不行(可空类型除外)
+ 赋值时处理不同，引用类型时赋值对象的引用，值类型是复制包含的值。