# 算法题 #

### [数学题]
1. 给n个数，随机输出m个不同的数
	解法：
```c++
void knuth(vector<int>nums, int m)  
{  
    srand((unsigned)time( NULL));
    int n = nums.size();
    for( int i = 0; i < n; i++)  
    {  
        if( rand()%(n-i) < m)  
        {  
            cout << i << "\t";  
            m--;  
        }
    }
    return;  
}
```
* 随着i的不断增大，rand()%(n-i)会不断减小，最后一定能随机地输出这m个数
****
### [动态规划]
1. 最大整除子集：给定一个非负数组，定义整除集如下：集合内所有元素都满足整除关系。求该数组的最大整除子集。
	解法：

   ```c++
   vector<int> largestDivisibleSubset(vector<int>& nums) {
    int size = nums.size();
    vector<vector<int>> dp(nums.size(), vector<int>(2));   
    // 定义一个二维数组，第一维表示以nums[i]结尾的最大整除子集的大小；
    //第二维表示该元素的前缀
    for (vector<int> &element : dp)
    {
        element[0] = 1;
        element[1] = -1;
    }
    int maxIndex = 0;
    for (int i = 1; i < size; i++)
    {
        for (int j = i - 1; j >= 0; j--)
        {
            if (nums[i] % nums[j] == 0 && dp[j][0] + 1 > dp[i][0]) 
            {
                dp[i][0] = dp[j][0] + 1;
                dp[i][1] = j;
                if (dp[i][0] > dp[maxIndex][0])
                {
                	maxIndex = i;
                }
            }
        }
    }
    vector<int> result;
    int m = maxIndex;
    while(m != -1)
    {
        result.push_back(nums[m]);
        m = dp[m][1];
    }
	 sort(result.begin(), result.end());
	 return result;
	}
	```
	
	****
	
2. 有台奇怪的打印机有以下两个特殊要求：打印机每次只能打印由 同一个字符 组成的序列。每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。
* 思路：对于s[i] == s[j]的情况,dp [i] [j] = dp [i] [j-1].对于s[i] !=s[j]的情况，则要分成两部分打印，从i打印到k，再从k+1打印到j。k取值在i+1到j-1范围内，选择dp[i] [k] + dp [k+1] [j]之和最小的

* 解法：
```c++
      int strangePrinter(string s) {
          int n = s.length();
          vector<vector<int>> f(n, vector<int>(n));
          for (int i = n - 1; i >= 0; i--) {
              f[i][i] = 1;
              for (int j = i + 1; j < n; j++) {
                  if (s[i] == s[j]) {
                      f[i][j] = f[i][j - 1];
                  } else {
                      int minn = INT_MAX;
                      for (int k = i; k < j; k++) {
                          minn = min(minn, f[i][k] + f[k + 1][j]);
                      }
                      f[i][j] = minn;
                  }
              }
          }
          return f[0][n - 1];
      }
  
```
****
3. 你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：要求每首歌至少播放一次。一首歌只有在其他 K 首歌播放完之后才能再次播放。

* 思路：设dp [i] [j]表示长度为i的歌单里恰有j首不同歌曲的情况。则有如下转移关系。前者表示第i首为新歌的情况，后者表示为老歌的情况，后者当k不为0时，表明第i首歌的前面k首都不能与第i首歌相同，且这些歌彼此也不会相同，直接排除了k首。
```c++
dp [i] [j] = dp [i-1] [j-1] * (N - j + 1) + dp [i - 1] [j] * (max(j - k, 0));
```
* 解法：
```c++
	int numMusicPlaylists(int N, int L, int K) {
        //dp[i][j]表示总共听了i首歌的情况下,且一共有j首不同的歌.对应的播放方法数
        //优化后可以去掉i的维度
        long mod = 1000000007;
        vector<long> dp(N+1,0);
        dp[1] = N;  
        for(int i = 2 ; i <= L ; ++i){
            for(int j = min(i,N) ; j > 0 ; --j){
                dp[j] = (dp[j-1] * ( N - j + 1) + dp[j] * (j > K ? j - K : 0) + mod) % mod;
            }
        }
        return dp[N];
    }
```
****
4. 有两个整型数组a,b。将a，b中相同的元素一一连起来，并保证线与线之间不交叉，请问最多有多少条这样的线？

```C++
/*动态规划：设一个dp二维数组,m*n。对于dp[i][j]，其表示a的前i个元素和b的前j个元素所具有的最多的线的个数。
那么对于dp[i][j]的值，分为两种情况：
1.当a[i] == b[j]时，dp[i][j] = dp[i - 1][j - 1]
2.当a[i] != b[j]时，dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
最后留意边界情况即可。*/
class Solution
{
public:
    int getLinesNum(vector<int>& a, vector<int> b)
    {
        int sizeA = a.size();
        int sizeB = b.size();
        int dp[sizeA][sizeB];
        if(a[0] == b[0])
        {
            dp[0][0] = 1;
		}
        else dp[0][0] = 0;
        for (int i = 1; i < sizeB; i++)
        {
            if ((dp[0][i - 1] != 1 && b[i] == a[0]) || dp[0][i - 1] == 1)
            {
                for(int k = i; k < sizeB; k++)
                {
                    dp[0][k] = 1;
				}
                break;
            }
            else
                dp[0][i] = 0;
		}
        for (int i = 1; i < sizeA; i++)
        {
            if ((dp[i - 1][0] != 1 && b[0] == a[i]) || dp[i - 1][0] == 1)
            {
                for(int k = i; k < sizeA; k++)
                {
                    dp[k][0] = 1;
				}
                break;
            }
            else
                dp[i][0] = 0;
		}
        for (int i = 1; i < sizeA; i++)
        {
            for (int j = 1; j < sizeB; j++)
            {
                if (a[i] == b[j])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
		}
        return dp[sizeA - 1][sizeB - 1];
	}
}
```
****
5. 假设有多个区间序列，请找到一个数，使得它所在的区间的个数最大

+ 思路：对于每个区间a,++dp[a[0]]，--dp[a[1]]，得到dp[i]的一系列值，最后计算得到前j个之和最大的点即可

### [双指针]

1.给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
	解法：

```c++
int lengthOfLongestSubstring(string s) {
    unordered_set<char> occ;
    int n = s.size();
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    int rk = -1, ans = 0;
    // 枚举左指针的位置，初始值隐性地表示为 -1
    for (int i = 0; i < n; ++i) {
        if (i != 0) {
            // 左指针向右移动一格，移除一个字符
            occ.erase(s[i - 1]);
        }
        while (rk + 1 < n && !occ.count(s[rk + 1])) {
            // 不断地移动右指针
            occ.insert(s[rk + 1]);
            ++rk;
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk - i + 1);
    }
    return ans;
}
```
* 从低到高，每轮结束后，在i到rk范围为以s[i]开头的最大不含有重复字符的子串。且必然由此得知i+1到rk也是不重复的，即rk随着i+1的递增也必然非降。
****
2. 求数组a中包含b中全部元素的最短连续子集/求字符串a中包含字符串b中所有字符的最短子串
* 思路：
首先，设置一个hash表，一个数组count，一个计数器appearCount。hash表用来存放b中各个字符，count存放每个b中的字符在a中出现的次数，appearCount存放已经出现了的字符个数。
然后，设置两个指针，front和rear，均指向开头。首先rear向后移动，对每次移动到的元素在hash表中查找，如果找到了，则对count中对应字符出现次数+1，同时如果是第一次出现，就对appearCount+1。直到appearCount == b.size()。然后front向后移动，对每次移动到的字符进行判断，如果是b中的字符，则对count-1，并判断减完的结果是不是0，是，则记录rear和，front，并当前的最短长度。紧接着rear再继续向后移动，如此循环，更新最短长度和区间索引。最后，rear到达了终点，front也完成最后一次更新，就停止。
* 解法：
```C++
vector<int> Question1(vector<int> &a, vector<int> &b)
{
    unordered_map<int, int> numbers;
    int appearCount = 0;
    int sizeA = a.size();
    int sizeB = b.size();
    int front = -1, rear = -1;
    int resultFront = 0, resultRear = a.size() - 1, length = a.size();
    vector<int> count(sizeB, 0);
    for (int i = 0; i < sizeB; i++)
    {
        numbers.insert(pair<int, int>(b[i], i));
    }
    while (rear < sizeA)	//用rear<a.size()好像有类型不匹配的问题
    {
        while (appearCount != sizeB)
        {
            rear++;
            if (rear < sizeA)
            {
                auto iter = numbers.find(a[rear]);
                if (iter != numbers.end())
                {
                    if (count[(*iter).second] == 0)
                    {
                        appearCount++;
                    }
                    count[(*iter).second]++;
                }
            }
            else
            {
                break;
            }
        }
        while (appearCount == sizeB)
        {
            front++;
            auto iter = numbers.find(a[front]);
            if (iter != numbers.end())
            {
                count[(*iter).second]--;
                if (!count[(*iter).second])
                    appearCount--;
            }
        }
        if (rear - front + 1 < length)
        {
            resultFront = front;
            resultRear = rear;
            length = rear - front + 1;
        }
    }
    return vector<int>({ resultFront,resultRear, length });
  }
```
****
3. 给定两个整型数组a,b。每次可以将a或者b中的一个数+1或者-1。问最少经过多少次这样的操作，可以使a中的最大值小于b中的最小值？
* 思路：首先我们可以对两数组的合并数组进行一个排序，同时利用一个结构数组array进行存储，这个结构包含了存储的数以及该数的个数，以及所属的数组是a还是b。然后利用双指针。寻找到a的最大值所在的位置pos1，以及b的最小值所在的位置。然后比较pos1与pos2所在位置的数的个数count。count少的先动，以pos1先动为例，要移动到下一个不小于array[pos2].num并且属于a的位置posTemp，移动的位数自然就是array[pos1].count * (pos1-posTemp)，同时要改变array[posTemp].count，应加上array[pos2].num。当然，如果没能找到下一个要移动到的结点，我们就直接移动到pos2-1处就行了。接着把pos2移动到posTemp，重复判断，移动，并记录移动次数即可。
****
### [递归与深度优先搜索]
1. 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例 1：
>输入：n = 3
>输出：["((()))","(()())","(())()","()(())","()()()"]
>示例 2：
>输入：n = 1
>输出：["()"]
* 思路：有关生成类的问题以及列出所有可能值的问题一般就涉及搜索算法，而搜索最主要的就是利用树的结构进行深度优先或者广度优先搜索。如果自己不想维护树，就一般使用递归算法。递归函数的递归出口写开头。
* 解法：
```C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> temp;
        //第一个必然是'('
        generateParenthesis(temp,n,"(",1,0);
        return temp;
    }
    void generateParenthesis(vector<string>&result,int n, string current, int leftNum, int rightNum)
    {
    	//左括号少于右括号数必然无效，直接出去。
        if (leftNum < rightNum || leftNum > n || rightNum > n)
        {
            return;
        }
        //左括号等于右括号数，且以及达到指定对数，则可以入列。同时也是递归出口
        if (leftNum == rightNum && leftNum == n)
        {
            result.push_back(current);
            return;
        }
        //否则要继续搜索。这里采用深度优先遍历。
        else{
            generateParenthesis(result,n,current + "(",leftNum+1,rightNum);
            generateParenthesis(result,n,current + ")",leftNum, rightNum+1);
        }
    }
};
```
****
### [单调栈]
1. 有n个人站队，所有的人全部向右看，个子高的可以看到个子低的发型，给出每个人的身高，问所有人能看到其他人发现总和是多少。
* 思路：单调栈分为单调递增栈和单调递减栈，通过使用单调栈我们可以访问到下一个比他大（小）的元素。也就是说在队列或数组中，我们需要通过比较前后元素的大小关系来解决问题时我们通常使用单调栈。在这个题目中，一个人是否能看到另一个人的发型，需要比较两人之间的高度，当然还有阻挡的问题。既然有关高度比较，可以使用单调栈，对于元素a以及栈顶元素stack.top()，只有a<b才入栈，否则出栈继续比较，直到a<stack.top() || stack.empty()，这样，完事之后，count+=(stack.size() - 1)；
```C++
	int totalVisiableNum(vector<int> & heights)
	{
		stack<int> lowerStack({heights[0]});
		int i = 1, size = heights.size();
		int count = 0;
		while(i < size)
		{
			if(heights[i] < lowerStack.top())
			{
				count += lowerStack.size();
				lowerStack.push(heights[i++]);
			}
			else
			{
				while(heights[i] >= lowerStack.top() || !lowerStack.empty())
				{
					lowerStack.pop();
				}
				count += lowerStack.size();
				lowerStack.push(heights[i++]);
			}
		}
		return count;
	}
```

### [优先队列]
1. 合并K个升序链表(力扣第23)

```C++
//优先队列：把所有的链表元素用小顶堆存储，然后再排出来即可
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() <= 0)
            return nullptr;
        ListNode * result = nullptr;
        ListNode * currentNode;
        priority_queue<int, vector<int>, greater<int>> tempQueue;
        for(auto iter = lists.begin(); iter != lists.end(); iter++)
        {
            ListNode* current = *iter;
            while(current)
            {
                tempQueue.push(current->val);
                current = current->next;
            }
        }
        if (!tempQueue.empty())
        {
            result = new ListNode(tempQueue.top());
            tempQueue.pop();
            currentNode = result;
        }
        while(!tempQueue.empty())
        {
            currentNode->next = new ListNode(tempQueue.top());
            tempQueue.pop();
            currentNode = currentNode->next;
        }
        return result;
    }
};
//分治法：用两个升序链表合并的方法，对其分治合并即可。
```
****
2. 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
+ 思路：使用两个栈，一个栈负责正常维护。另一个辅助栈则作为一个单调非降栈维护，对于这个辅助栈，每当要入栈新元素时，如果该辅助栈的端顶元素值大于它，则正常入栈它，否则就入栈一次端顶元素。出栈时，则同时出栈即可。
```c++
class MinStack {
    stack<int> thisstack;
    stack<int> minstack;
public:
    /** initialize your data structure here. */
    MinStack() {
        minstack.push(INT_MAX);
    }
    
    void push(int x) {
        thisstack.push(x);
        minstack.push(std::min(minstack.top(),x));
    }
    
    void pop() {
        thisstack.pop();
        minstack.pop();
    }
    
    int top() {
        return thisstack.top();
    }
    
    int min() {
        return minstack.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```

### [哈希表]

1. ![](pictures/哈希表1.png)

+ 思路：在考虑复制时，最容易想到顺序复制，但是顺序复制会发现有些random没法复制，所以得换种办法；由于对每个结点的操作都是复制，可以采用递归算法。
  + 因为每个原结点都对应一个新复制的结点，所以具体来说，可以使用哈希表unordered_map<Node * ，Node *>，当一个结点要进行复制时，如果哈希表里没有，则说明要复制，并加入哈希表，同时这个结点指向的next和random也是如此。故可以进行递归。最后返回哈希表里的新结点值
  + 对于边界情况，则是结点为空的情况为空直接返回nullptr即可

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    unordered_map<Node*, Node*> nodeMap;
    Node* copyRandomList(Node* head) {
        if (head == nullptr)
            return nullptr;
        if (!nodeMap.count(head))
        {
            Node * newHead = new Node(head->val);
            nodeMap[head] = newHead;
            newHead->next = copyRandomList(head->next);
            newHead->random = copyRandomList(head->random);
        }
        return nodeMap[head];
    }
};
```

****

### [树遍历]

1. 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

+ 思路：对于一棵二叉搜索树，它的中序遍历即可输出单调升序。那么我们可以利用它，首先是递归思路，我们进行深度优先遍历，当dfs(root->left)完成时，它会得到root的左边的结点pre，这时我们对pre进行判断，如果pre为空，说明当前root就是头结点，不需要处理连接，但是要把它记录成head；如果pre不为空，说明得到了root的左边结点，这时我们建立root和pre的连接，并将pre更新为root，再进行dfs(root->right)，就可以完成右边的遍历了。

 ```c++
 /*
 // Definition for a Node.
 class Node {
 public:
     int val;
     Node* left;
     Node* right;
 
     Node() {}
 
     Node(int _val) {
         val = _val;
         left = NULL;
         right = NULL;
     }
 
     Node(int _val, Node* _left, Node* _right) {
         val = _val;
         left = _left;
         right = _right;
     }
 };
 */
 class Solution {
 public:
     Node* treeToDoublyList(Node* root) {
         if(root == nullptr) return nullptr;
         dfs(root);
         head->left = pre;
         pre->right = head;
         return head;
     }
 private:
     Node *pre, *head;
     void dfs(Node* cur) {
         if(cur == nullptr) return;
         dfs(cur->left);
         if(pre != nullptr) pre->right = cur;
         else head = cur;
         cur->left = pre;
         pre = cur;
         dfs(cur->right);
     }
 };
 ```

****

### [排列问题]
1. 输入一个字符串，打印字符串的所有排列

* 思路：首先考虑递归办法，第0个位置有n个选择，第i个位置有n-i种选择。对于某个位置已经被选了的，就进行记录，防止再选，所以需要使用一个同样大小的标记数组。递归函数的作用就是确定第i个位置的元素。对于去重，则是如下操作，首先是对字符串排序，让相同的字符相邻。然后对于相同的字符a0，a1，仅当a0被选取时，才允许选择a1。不允许a0没选就选了a1，这样保证只有一个组合，不会重复

```c++
class Solution {
public:
    vector<string> rec;
    vector<int> vis;

    void backtrack(const string& s, int i, int n, string& perm) {
        if (i == n) {
            rec.push_back(perm);
            return;
        }//到了第n个时，说明已经获得了一个排列
        for (int j = 0; j < n; j++) {
            if (vis[j] || (j > 0 && !vis[j - 1] && s[j - 1] == s[j])) {
                continue;
            }
            vis[j] = true;
            perm.push_back(s[j]);
            backtrack(s, i + 1, n, perm);
            perm.pop_back();
            vis[j] = false;
        }
    }

    vector<string> permutation(string s) {
        int n = s.size();
        vis.resize(n);
        sort(s.begin(), s.end());
        string perm;
        backtrack(s, 0, n, perm);
        return rec;
    }
};
```

+ 思路2：先对s进行排序，然后每次获得下一个全排列即可

```c++
class Solution {
public:
    bool nextPermutation(string& s) {
        int i = s.size() - 2;
        while (i >= 0 && s[i] >= s[i + 1]) {
            i--;
        }
        if (i < 0) {
            return false;
        }//先找到一个位置，该位置的元素小于后面一个元素
        int j = s.size() - 1;
        while (j >= 0 && s[i] >= s[j]) {
            j--;
        }
        swap(s[i], s[j]);//从后面的元素中找一个最小的大于该元素的，并交换
        reverse(s.begin() + i + 1, s.end());
        //将该元素之后的进行排序，得到下一个排列
        return true;
    }

    vector<string> permutation(string s) {
        vector<string> ret;
        sort(s.begin(), s.end());//默认从小到大
        do {
            ret.push_back(s);
        } while (nextPermutation(s));
        return ret;
    }
};
```

****

### [对顶堆]
1. [剑指offer41] 维护数据流中的中位数
+ 思路：没啥好说的，直接对顶堆即可。注意好对顶堆的维护方法
```c++
class MedianFinder {
public:
    /** initialize your data structure here. */
    //对顶堆
    priority_queue<int> bigTopHeap;
    priority_queue<int, vector<int>, greater<int>> smallTopHeap;   
    void addNum(int num) {
        if (bigTopHeap.size() == 0 || num < bigTopHeap.top())
        {
            bigTopHeap.push(num);
        }
        else
            smallTopHeap.push(num);
        if (bigTopHeap.size() > smallTopHeap.size() + 1) smallTopHeap.push(bigTopHeap.top()), bigTopHeap.pop();
        if (smallTopHeap.size() > bigTopHeap.size() + 1) bigTopHeap.push(smallTopHeap.top()), smallTopHeap.pop();
        //如果不是求中位数，则改这里就行
    }
    
    double findMedian() {
        if ((smallTopHeap.size() + bigTopHeap.size())%2)
        {
            if (smallTopHeap.size() > bigTopHeap.size())
                return smallTopHeap.top();
            return bigTopHeap.top();
        }
        return (bigTopHeap.top() + smallTopHeap.top())/2.0;
    }
};
```

****

### [贪心算法]

#### 贪心算法简述

+ 贪心算法主要在于从局部最优得到全局最优。基本问题如：区间问题，分配问题。

1. [LeetCode_605]假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

   给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。

+ 思路：先将flowerbed分成两个部分，一前一后，在前面可种植数已确定的情况下，前面的最后一个可种植位置越在前面，后面的可种植数量就更多。所以，这里的贪心策略就是：每次都使得该种植位置尽量靠左。

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int size = flowerbed.size();
        if (size < 2 * n - 1)
            return false;
        int count = 0;
        for (int i = 0; i < size;)
        {
            if (flowerbed[i] == 0)
            {
                if (i == size - 1 || flowerbed[i + 1] == 0)
                {
                    count++;
                    i+=2;
                }
                else
                {
                    i++;
                }
            }
            else
                i+=2;
        }
        return count >= n;
    }
};
```

****

2.[LeetCode_452]假设有一堆气球，每个气球有左右边界，可能存在重叠，现在可以使用飞针刺穿之，对于重叠的气球，可以完全穿透，请问最少使用多少个针头可以全部刺穿？

+ 思路：首先判断问题类型，很明显，这里区间问题的气息浓厚，可能需要进行排序，不妨利用左边界升序排序好了。得到这个结果后，进行分析：我们知道，对气球i，引爆它最后的机会在它的右边界。那么如果按照区间顺序得到的第i +1个气球的右边界在气球i的左边，则我们可以同时击穿这两个气球，同时击穿的最后机会在i+1的右边界；如果i+1气球的右边界在i气球的右边，但i+1气球的左边界在其左边，则我们依然可同时击穿，击穿的最后机会在i的右边界；但如果i+1气球完全在i气球的右边，则无法同时击穿，只能多用一个刺针。

  这里的贪心策略在于：对于每个气球，我都找能击穿它的最右边的位置，看看在这之前能不能尽量击穿更多的气球。

```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), [](const vector<int>& a,const vector<int>& b){return a[0] < b[0];});
        int pos = points[0][1];//记录第1个气球的右边界
        int count = 1;
        for(const vector<int>& u : points)
        {
            if (u[1] < pos)
            {
                pos = u[1];
            }//如果下一个气球的右边界在其左边，我就移动到击穿这个气球的最后位置
            else if (u[0] > pos)
            {
                pos = u[1];
                count++;
            }//如果下一个气球的右边界在其右，且左边界也在其右，我就得多用一个针头了。前面这些击穿了，就移动到该气球的右边界，进行下一个循环。
        }
        return count;
    }
};
```

