# 算法题 #

### [数学题]
1. 给n个数，随机输出m个不同的数
	解法：
```c++
void knuth(vector<int>nums, int m)  
{  
    srand((unsigned)time( NULL));
    int n = nums.size();
    for( int i = 0; i < n; i++)  
    {  
        if( rand()%(n-i) < m)  
        {  
            cout << i << "\t";  
            m--;  
        }
    }
    return;  
}
```
* 随着i的不断增大，rand()%(n-i)会不断减小，最后一定能随机地输出这m个数
****
### [动态规划]
1. 最大整除子集：给定一个非负数组，定义整除集如下：集合内所有元素都满足整除关系。求该数组的最大整除子集。
	解法：

   ```c++
   vector<int> largestDivisibleSubset(vector<int>& nums) {
    int size = nums.size();
    vector<vector<int>> dp(nums.size(), vector<int>(2));   
    // 定义一个二维数组，第一维表示以nums[i]结尾的最大整除子集的大小；
    //第二维表示该元素的前缀
    for (vector<int> &element : dp)
    {
        element[0] = 1;
        element[1] = -1;
    }
    int maxIndex = 0;
    for (int i = 1; i < size; i++)
    {
        for (int j = i - 1; j >= 0; j--)
        {
            if (nums[i] % nums[j] == 0 && dp[j][0] + 1 > dp[i][0]) 
            {
                dp[i][0] = dp[j][0] + 1;
                dp[i][1] = j;
                if (dp[i][0] > dp[maxIndex][0])
                {
                	maxIndex = i;
                }
            }
        }
    }
    vector<int> result;
    int m = maxIndex;
    while(m != -1)
    {
        result.push_back(nums[m]);
        m = dp[m][1];
    }
	 sort(result.begin(), result.end());
	 return result;
	}
	```
	
	****
	
2. 有台奇怪的打印机有以下两个特殊要求：打印机每次只能打印由 同一个字符 组成的序列。每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。
* 思路：对于s[i] == s[j]的情况,dp [i] [j] = dp [i] [j-1].对于s[i] !=s[j]的情况，则要分成两部分打印，从i打印到k，再从k+1打印到j。k取值在i+1到j-1范围内，选择dp[i] [k] + dp [k+1] [j]之和最小的

* 解法：
```c++
      int strangePrinter(string s) {
          int n = s.length();
          vector<vector<int>> f(n, vector<int>(n));
          for (int i = n - 1; i >= 0; i--) {
              f[i][i] = 1;
              for (int j = i + 1; j < n; j++) {
                  if (s[i] == s[j]) {
                      f[i][j] = f[i][j - 1];
                  } else {
                      int minn = INT_MAX;
                      for (int k = i; k < j; k++) {
                          minn = min(minn, f[i][k] + f[k + 1][j]);
                      }
                      f[i][j] = minn;
                  }
              }
          }
          return f[0][n - 1];
      }
  
```
****
3. 你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：要求每首歌至少播放一次。一首歌只有在其他 K 首歌播放完之后才能再次播放。

* 思路：设dp [i] [j]表示长度为i的歌单里恰有j首不同歌曲的情况。则有如下转移关系。前者表示第i首为新歌的情况，后者表示为老歌的情况，后者当k不为0时，表明第i首歌的前面k首都不能与第i首歌相同，且这些歌彼此也不会相同，直接排除了k首。
```c++
dp [i] [j] = dp [i-1] [j-1] * (N - j + 1) + dp [i - 1] [j] * (max(j - k, 0));
```
* 解法：
```c++
	int numMusicPlaylists(int N, int L, int K) {
        //dp[i][j]表示总共听了i首歌的情况下,且一共有j首不同的歌.对应的播放方法数
        //优化后可以去掉i的维度
        long mod = 1000000007;
        vector<long> dp(N+1,0);
        dp[1] = N;  
        for(int i = 2 ; i <= L ; ++i){
            for(int j = min(i,N) ; j > 0 ; --j){
                dp[j] = (dp[j-1] * ( N - j + 1) + dp[j] * (j > K ? j - K : 0) + mod) % mod;
            }
        }
        return dp[N];
    }
```
****
有两个整型数组a,b。将a，b中相同的元素一一连起来，并保证线与线之间不交叉，请问最多有多少条这样的线？

```C++
/*动态规划：设一个dp二维数组,m*n。对于dp[i][j]，其表示a的前i个元素和b的前j个元素所具有的最多的线的个数。
那么对于dp[i][j]的值，分为两种情况：
1.当a[i] == b[j]时，dp[i][j] = dp[i - 1][j - 1]
2.当a[i] != b[j]时，dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
最后留意边界情况即可。*/
class Solution
{
public:
    int getLinesNum(vector<int>& a, vector<int> b)
    {
        int sizeA = a.size();
        int sizeB = b.size();
        int dp[sizeA][sizeB];
        if(a[0] == b[0])
        {
            dp[0][0] = 1;
		}
        else dp[0][0] = 0;
        for (int i = 1; i < sizeB; i++)
        {
            if ((dp[0][i - 1] != 1 && b[i] == a[0]) || dp[0][i - 1] == 1)
            {
                for(int k = i; k < sizeB; k++)
                {
                    dp[0][k] = 1;
				}
                break;
            }
            else
                dp[0][i] = 0;
		}
        for (int i = 1; i < sizeA; i++)
        {
            if ((dp[i - 1][0] != 1 && b[0] == a[i]) || dp[i - 1][0] == 1)
            {
                for(int k = i; k < sizeA; k++)
                {
                    dp[k][0] = 1;
				}
                break;
            }
            else
                dp[i][0] = 0;
		}
        for (int i = 1; i < sizeA; i++)
        {
            for (int j = 1; j < sizeB; j++)
            {
                if (a[i] == b[j])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
		}
        return dp[sizeA - 1][sizeB - 1];
	}
}
```
****
### [双指针]
1.给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
	解法：

```c++
int lengthOfLongestSubstring(string s) {
    unordered_set<char> occ;
    int n = s.size();
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    int rk = -1, ans = 0;
    // 枚举左指针的位置，初始值隐性地表示为 -1
    for (int i = 0; i < n; ++i) {
        if (i != 0) {
            // 左指针向右移动一格，移除一个字符
            occ.erase(s[i - 1]);
        }
        while (rk + 1 < n && !occ.count(s[rk + 1])) {
            // 不断地移动右指针
            occ.insert(s[rk + 1]);
            ++rk;
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk - i + 1);
    }
    return ans;
}
```
* 从低到高，每轮结束后，在i到rk范围为以s[i]开头的最大不含有重复字符的子串。且必然由此得知i+1到rk也是不重复的，即rk随着i+1的递增也必然非降。
****
2. 求数组a中包含b中全部元素的最短连续子集/求字符串a中包含字符串b中所有字符的最短子串
* 思路：
首先，设置一个hash表，一个数组count，一个计数器appearCount。hash表用来存放b中各个字符，count存放每个b中的字符在a中出现的次数，appearCount存放已经出现了的字符个数。
然后，设置两个指针，front和rear，均指向开头。首先rear向后移动，对每次移动到的元素在hash表中查找，如果找到了，则对count中对应字符出现次数+1，同时如果是第一次出现，就对appearCount+1。直到appearCount == b.size()。然后front向后移动，对每次移动到的字符进行判断，如果是b中的字符，则对count-1，并判断减完的结果是不是0，是，则记录rear和，front，并当前的最短长度。紧接着rear再继续向后移动，如此循环，更新最短长度和区间索引。最后，rear到达了终点，front也完成最后一次更新，就停止。
* 解法：
```C++
vector<int> Question1(vector<int> &a, vector<int> &b)
{
    unordered_map<int, int> numbers;
    int appearCount = 0;
    int sizeA = a.size();
    int sizeB = b.size();
    int front = -1, rear = -1;
    int resultFront = 0, resultRear = a.size() - 1, length = a.size();
    vector<int> count(sizeB, 0);
    for (int i = 0; i < sizeB; i++)
    {
        numbers.insert(pair<int, int>(b[i], i));
    }
    while (rear < sizeA)	//用rear<a.size()好像有类型不匹配的问题
    {
        while (appearCount != sizeB)
        {
            rear++;
            if (rear < sizeA)
            {
                auto iter = numbers.find(a[rear]);
                if (iter != numbers.end())
                {
                    if (count[(*iter).second] == 0)
                    {
                        appearCount++;
                    }
                    count[(*iter).second]++;
                }
            }
            else
            {
                break;
            }
        }
        while (appearCount == sizeB)
        {
            front++;
            auto iter = numbers.find(a[front]);
            if (iter != numbers.end())
            {
                count[(*iter).second]--;
                if (!count[(*iter).second])
                    appearCount--;
            }
        }
        if (rear - front + 1 < length)
        {
            resultFront = front;
            resultRear = rear;
            length = rear - front + 1;
        }
    }
    return vector<int>({ resultFront,resultRear, length });
  }
```
****
3. 给定两个整型数组a,b。每次可以将a或者b中的一个数+1或者-1。问最少经过多少次这样的操作，可以使a中的最大值小于b中的最小值？
* 思路：首先我们可以对两数组的合并数组进行一个排序，同时利用一个结构数组array进行存储，这个结构包含了存储的数以及该数的个数，以及所属的数组是a还是b。然后利用双指针。寻找到a的最大值所在的位置pos1，以及b的最小值所在的位置。然后比较pos1与pos2所在位置的数的个数count。count少的先动，以pos1先动为例，要移动到下一个不小于array[pos2].num并且属于a的位置posTemp，移动的位数自然就是array[pos1].count * (pos1-posTemp)，同时要改变array[posTemp].count，应加上array[pos2].num。当然，如果没能找到下一个要移动到的结点，我们就直接移动到pos2-1处就行了。接着把pos2移动到posTemp，重复判断，移动，并记录移动次数即可。
****
### [递归与深度优先搜索]
1. 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例 1：
>输入：n = 3
>输出：["((()))","(()())","(())()","()(())","()()()"]
>示例 2：
>输入：n = 1
>输出：["()"]
* 思路：有关生成类的问题以及列出所有可能值的问题一般就涉及搜索算法，而搜索最主要的就是利用树的结构进行深度优先或者广度优先搜索。如果自己不想维护树，就一般使用递归算法。递归函数的递归出口写开头。
* 解法：
```C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> temp;
        //第一个必然是'('
        generateParenthesis(temp,n,"(",1,0);
        return temp;
    }
    void generateParenthesis(vector<string>&result,int n, string current, int leftNum, int rightNum)
    {
    	//左括号少于右括号数必然无效，直接出去。
        if (leftNum < rightNum || leftNum > n || rightNum > n)
        {
            return;
        }
        //左括号等于右括号数，且以及达到指定对数，则可以入列。同时也是递归出口
        if (leftNum == rightNum && leftNum == n)
        {
            result.push_back(current);
            return;
        }
        //否则要继续搜索。这里采用深度优先遍历。
        else{
            generateParenthesis(result,n,current + "(",leftNum+1,rightNum);
            generateParenthesis(result,n,current + ")",leftNum, rightNum+1);
        }
    }
};
```
****
### [单调栈]
1. 有n个人站队，所有的人全部向右看，个子高的可以看到个子低的发型，给出每个人的身高，问所有人能看到其他人发现总和是多少。
* 思路：单调栈分为单调递增栈和单调递减栈，通过使用单调栈我们可以访问到下一个比他大（小）的元素。也就是说在队列或数组中，我们需要通过比较前后元素的大小关系来解决问题时我们通常使用单调栈。在这个题目中，一个人是否能看到另一个人的发型，需要比较两人之间的高度，当然还有阻挡的问题。既然有关高度比较，可以使用单调栈，对于元素a以及栈顶元素stack.top()，只有a<b才入栈，否则出栈继续比较，直到a<stack.top() || stack.empty()，这样，完事之后，count+=(stack.size() - 1)；
```C++
	int totalVisiableNum(vector<int> & heights)
	{
		stack<int> lowerStack({heights[0]});
		int i = 1, size = heights.size();
		int count = 0;
		while(i < size)
		{
			if(heights[i] < lowerStack.top())
			{
				count += lowerStack.size();
				lowerStack.push(heights[i++]);
			}
			else
			{
				while(heights[i] >= lowerStack.top() || !lowerStack.empty())
				{
					lowerStack.pop();
				}
				count += lowerStack.size();
				lowerStack.push(heights[i++]);
			}
		}
		return count;
	}
```

### [优先队列]
1. 合并K个升序链表(力扣第23)

```C++
//优先队列：把所有的链表元素用小顶堆存储，然后再排出来即可
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() <= 0)
            return nullptr;
        ListNode * result = nullptr;
        ListNode * currentNode;
        priority_queue<int, vector<int>, greater<int>> tempQueue;
        for(auto iter = lists.begin(); iter != lists.end(); iter++)
        {
            ListNode* current = *iter;
            while(current)
            {
                tempQueue.push(current->val);
                current = current->next;
            }
        }
        if (!tempQueue.empty())
        {
            result = new ListNode(tempQueue.top());
            tempQueue.pop();
            currentNode = result;
        }
        while(!tempQueue.empty())
        {
            currentNode->next = new ListNode(tempQueue.top());
            tempQueue.pop();
            currentNode = currentNode->next;
        }
        return result;
    }
};
//分治法：用两个升序链表合并的方法，对其分治合并即可。
```
****
2. 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
+ 思路：使用两个栈，一个栈负责正常维护。另一个辅助栈则作为一个单调非降栈维护，对于这个辅助栈，每当要入栈新元素时，如果该辅助栈的端顶元素值大于它，则正常入栈它，否则就入栈一次端顶元素。出栈时，则同时出栈即可。
```c++
class MinStack {
    stack<int> thisstack;
    stack<int> minstack;
public:
    /** initialize your data structure here. */
    MinStack() {
        minstack.push(INT_MAX);
    }
    
    void push(int x) {
        thisstack.push(x);
        minstack.push(std::min(minstack.top(),x));
    }
    
    void pop() {
        thisstack.pop();
        minstack.pop();
    }
    
    int top() {
        return thisstack.top();
    }
    
    int min() {
        return minstack.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```

