# 算法题 #

### [数学题]
1. 给n个数，随机输出m个不同的数
	解法：
```c++
void knuth(vector<int>nums, int m)  
{  
    srand((unsigned)time( NULL));
    int n = nums.size();
    for( int i = 0; i < n; i++)  
    {  
        if( rand()%(n-i) < m)  
        {  
            cout << i << "\t";  
            m--;  
        }
    }
    return;  
}
```
* 随着i的不断增大，rand()%(n-i)会不断减小，最后一定能随机地输出这m个数

2. [剑指offer 56]一个int数组，除了两个数字以外，其它数字都出现了2次，求出这两个只出现1次的数字。

+ 思路：之前有个题，是只有一个数字只出现一次，其余出现2次，采用的是直接全部异或的办法，最终就能得到答案。而这个题，可以采取分组异或的办法，如果能让这两个数字出现在不同的分组里，且其它相同的数字会分在相同分组，那么就转换成之前的那个问题了。首先全部异或，得到的最终应该是result = x^y，假设这个结果的第i位为0，则表示x和y的第i位相同，为1，则表示两者第i位不相同。于是我们可以任意选择result的一个为1的bit作为划分条件，对于其它出现两次的数k，k与这个0000100000（假设是这个）异或会得到相同的结果，就分在同一个组，而对于x，y这两个只出现一次的，则会在这组上呈现不同，进而分到不同的组去。于是便完成了分组，最后就只要各自异或就可以得到答案了。

  ```c++
  class Solution {
  public:
      vector<int> singleNumbers(vector<int>& nums) {
          int result = 0;
          for (int val : nums)
              result ^= val;
          int i = 1;
          while((result & i) == 0)
              i <<= 1;
          int left = 0, right = 0;
          for (int val : nums)
          {
              if ((val & i) == 0)
                  left^=val;
              else
                  right^=val;
          }
          return {left, right};
      }
  };
  ```


3.[剑指offer56]数组中数字出现的次数。

​	有个数组nums中除了一个数字出现1次以外，其余的都出现三次，找出这个数字

+ 思路：这个题目的做法可以认为是这一类题目的通用做法。我们对nums内的每个数字进行处理，统计每一个二进制位，它如果为1，则对应计数+1。全部处理完毕，再对所有二进制位取3的余数，剩下的就是只出现1次的这个数所拥有的二进制位了。

  ```c++
  class Solution {
  public:
      int singleNumber(vector<int>& nums) {
          vector<int> bits(32, 0);
          for (int val : nums)
          {
              int x = 1;
              for (int i = 0; i < 32; ++i)
              {
                  if (val & x)
                      ++bits[i];
                  val >>= 1;
              }
          }
          int j = 1;
          int result = 0;
          for (int k = 0; k < 32; ++k)
          {
              bits[k]%=3;
              if (bits[k]){
                  result += j << k;
              }
          }
          return result;
      }
  };
  ```

****
### [动态规划]

#### 算法简述

+ 动态规划实际就是有记忆的递归。可用动态规划的问题常常需要有最优子结构。
+ 常见的动态规划的做法：
  + 使用一维的dp[i]
    + 仅包含前i个元素时问题的解，以求得dp[i + 1]
    + 表示以dp[i]结尾的解，这个往往是临时结果，一般都要求最大的值
  + 使用二维dp\[i][j]
    + 表示从nums[i]到nums[j]这一个区间内问题的解
    + 当然还有其它表示，比如常见的背包问题
+ 注意点：
  + 对于二维dp，常常需要根据转移方程和可以达成的初始条件好好考虑求解顺序。

#### 相关问题

1. 最大整除子集：给定一个非负数组，定义整除集如下：集合内所有元素都满足整除关系。求该数组的最大整除子集。
	解法：

   ```c++
   vector<int> largestDivisibleSubset(vector<int>& nums) {
    int size = nums.size();
    vector<vector<int>> dp(nums.size(), vector<int>(2));   
    // 定义一个二维数组，第一维表示以nums[i]结尾的最大整除子集的大小；
    //第二维表示该元素的前缀
    for (vector<int> &element : dp)
    {
        element[0] = 1;
        element[1] = -1;
    }
    int maxIndex = 0;
    for (int i = 1; i < size; i++)
    {
        for (int j = i - 1; j >= 0; j--)
        {
            if (nums[i] % nums[j] == 0 && dp[j][0] + 1 > dp[i][0]) 
            {
                dp[i][0] = dp[j][0] + 1;
                dp[i][1] = j;
                if (dp[i][0] > dp[maxIndex][0])
                {
                	maxIndex = i;
                }
            }
        }
    }
    vector<int> result;
    int m = maxIndex;
    while(m != -1)
    {
        result.push_back(nums[m]);
        m = dp[m][1];
    }
	 sort(result.begin(), result.end());
	 return result;
	}
	```
	
	****
	
2. 有台奇怪的打印机有以下两个特殊要求：打印机每次只能打印由 同一个字符 组成的序列。每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。
* 思路：对于s[i] == s[j]的情况,dp [i] [j] = dp [i] [j-1].对于s[i] !=s[j]的情况，则要分成两部分打印，从i打印到k，再从k+1打印到j。k取值在i+1到j-1范围内，选择dp[i] [k] + dp [k+1] [j]之和最小的

* 解法：
```c++
      int strangePrinter(string s) {
          int n = s.length();
          vector<vector<int>> f(n, vector<int>(n));
          for (int i = n - 1; i >= 0; i--) {
              f[i][i] = 1;
              for (int j = i + 1; j < n; j++) {
                  if (s[i] == s[j]) {
                      f[i][j] = f[i][j - 1];
                  } else {
                      int minn = INT_MAX;
                      for (int k = i; k < j; k++) {
                          minn = min(minn, f[i][k] + f[k + 1][j]);
                      }
                      f[i][j] = minn;
                  }
              }
          }
          return f[0][n - 1];
      }
  
```
****
3. 你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：要求每首歌至少播放一次。一首歌只有在其他 K 首歌播放完之后才能再次播放。

* 思路：设dp [i] [j]表示长度为i的歌单里恰有j首不同歌曲的情况。则有如下转移关系。前者表示第i首为新歌的情况，后者表示为老歌的情况，后者当k不为0时，表明第i首歌的前面k首都不能与第i首歌相同，且这些歌彼此也不会相同，直接排除了k首。
```c++
dp [i] [j] = dp [i-1] [j-1] * (N - j + 1) + dp [i - 1] [j] * (max(j - k, 0));
```
* 解法：
```c++
	int numMusicPlaylists(int N, int L, int K) {
        //dp[i][j]表示总共听了i首歌的情况下,且一共有j首不同的歌.对应的播放方法数
        //优化后可以去掉i的维度
        long mod = 1000000007;
        vector<long> dp(N+1,0);
        dp[1] = N;  
        for(int i = 2 ; i <= L ; ++i){
            for(int j = min(i,N) ; j > 0 ; --j){
                dp[j] = (dp[j-1] * ( N - j + 1) + dp[j] * (j > K ? j - K : 0) + mod) % mod;
            }
        }
        return dp[N];
    }
```
****
4. 有两个整型数组a,b。将a，b中相同的元素一一连起来，并保证线与线之间不交叉，请问最多有多少条这样的线？

```C++
/*动态规划：设一个dp二维数组,m*n。对于dp[i][j]，其表示a的前i个元素和b的前j个元素所具有的最多的线的个数。
那么对于dp[i][j]的值，分为两种情况：
1.当a[i] == b[j]时，dp[i][j] = dp[i - 1][j - 1]
2.当a[i] != b[j]时，dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
最后留意边界情况即可。*/
class Solution
{
public:
    int getLinesNum(vector<int>& a, vector<int> b)
    {
        int sizeA = a.size();
        int sizeB = b.size();
        int dp[sizeA][sizeB];
        if(a[0] == b[0])
        {
            dp[0][0] = 1;
		}
        else dp[0][0] = 0;
        for (int i = 1; i < sizeB; i++)
        {
            if ((dp[0][i - 1] != 1 && b[i] == a[0]) || dp[0][i - 1] == 1)
            {
                for(int k = i; k < sizeB; k++)
                {
                    dp[0][k] = 1;
				}
                break;
            }
            else
                dp[0][i] = 0;
		}
        for (int i = 1; i < sizeA; i++)
        {
            if ((dp[i - 1][0] != 1 && b[0] == a[i]) || dp[i - 1][0] == 1)
            {
                for(int k = i; k < sizeA; k++)
                {
                    dp[k][0] = 1;
				}
                break;
            }
            else
                dp[i][0] = 0;
		}
        for (int i = 1; i < sizeA; i++)
        {
            for (int j = 1; j < sizeB; j++)
            {
                if (a[i] == b[j])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
		}
        return dp[sizeA - 1][sizeB - 1];
	}
}
```
****
5. 假设有多个区间序列，请找到一个数，使得它所在的区间的个数最大

+ 思路：对于每个区间a,++dp[a[0]]，--dp[a[1]]，得到dp[i]的一系列值，最后计算得到前j个之和最大的点即可

****

6. [哈希，力扣1218  最长定差子序列]给定一个整数数组arr和一个整数difference，找出并返回arr中最长等差子序列长度，该序列中相邻元素之间的差等于difference

   + 思路：首先可以按照动态规划的思路，先从一维考虑。dp[i]可以表示以arr[i]结尾的最长序列的长度。那么对于其求解，可以得到dp[i] = dp[r] + 1，其中arr[r]应等于arr[i] - difference，如果找不到这样的r，则dp[i] = 1。至此可以求解。

     <font color = "red">对于这种求dp[i]要遍历前面所有元素以找到指定元素的，可以利用哈希表进行优化</font>

```c++
class Solution {
public:
    int longestSubsequence(vector<int>& arr, int difference) {
        int size = arr.size();
        unordered_map<int, int> dp;
        // 使用哈希表优化
        int result = 0;
        for(int v : arr)
        {
            dp[v] = dp[v - difference] + 1;
            // 对于不存在的键，其值默认全0
            result = max(result, dp[v]);
        }
        return result;
    }
};
```



### [双指针与滑动窗口]

#### 算法简述

+ **双指针**：主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多 个数组的**多指针**。
+ **滑动窗口**：若两个指针指向同一数组，遍历方向相同且不会相交，则也称为**滑动窗口**（两个指针包围的区域即为当前的窗口），经常用于**区间搜索求最值**，比如**快慢指针**。 若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。这常用于解决字符串的子串问题
+ 一些典型问题
  + 接雨水：遍历方向相反的双指针。
  + 归并两个有序链表：一般的双指针
  + 检测单链表有无环：遍历方向相同的快慢指针。如果要找到环路的开始点，则在两指针相遇时，把快指针重置到头结点，接着使用和慢指针一样的速度前进，再次相遇的点即为环路的开始点。

#### 相关题目

1. 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。

+ 思路：我们设置一个滑动窗口，这意味着有一个左指针，一个右指针。我们希望指针范围内能表示一个无重复的子串，这样就可以通过左右指针的位置right - left + 1得到子串长度。要做到这点，意味着每次加入的字符必须是没出现过的，在它加入前，必须确保它不存在，如果窗口中有它，就得滑动边界让它滑出窗口。

```c++
int lengthOfLongestSubstring(string s) {
    unordered_set<char> occ;
    int n = s.size();
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    int rk = -1, ans = 0;
    // 枚举左指针的位置，初始值隐性地表示为 -1
    for (int i = 0; i < n; ++i) {
        if (i != 0) {
            // 左指针向右移动一格，移除一个字符
            occ.erase(s[i - 1]);
        }
        while (rk + 1 < n && !occ.count(s[rk + 1])) {
            // 不断地移动右指针
            occ.insert(s[rk + 1]);
            ++rk;
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk - i + 1);
    }
    return ans;
}
```
* 从低到高，每轮结束后，在i到rk范围为以s[i]开头的最大不含有重复字符的子串。且必然由此得知i+1到rk也是不重复的，即rk随着i+1的递增也必然非降。
****
2. 求数组a中包含b中全部元素的最短连续子集/求字符串a中包含字符串b中所有字符的最短子串

* 思路：
首先，设置一个hash表，一个数组count，一个计数器appearCount。hash表用来存放b中各个字符，count存放每个b中的字符在a中出现的次数，appearCount存放已经出现了的字符个数。
然后，设置两个指针，front和rear，均指向开头。首先rear向后移动，对每次移动到的元素在hash表中查找，如果找到了，则对count中对应字符出现次数+1，同时如果是第一次出现，就对appearCount+1。直到appearCount == b.size()。然后front向后移动，对每次移动到的字符进行判断，如果是b中的字符，则对count-1，并判断减完的结果是不是0，是，则记录rear和front，并计算当前的最短长度。紧接着rear再继续向后移动，如此循环，更新最短长度和区间索引。最后，rear到达了终点，front也完成最后一次更新，就停止。
* 解法：
```C++
vector<int> Question1(vector<int> &a, vector<int> &b)
{
    unordered_map<int, int> numbers;
    int appearCount = 0;
    int sizeA = a.size();
    int sizeB = b.size();
    int front = -1, rear = -1;
    int resultFront = 0, resultRear = a.size() - 1, length = a.size();
    vector<int> count(sizeB, 0);
    for (int i = 0; i < sizeB; i++)
    {
        numbers.insert(pair<int, int>(b[i], i));
    }
    while (rear < sizeA)	//用rear<a.size()好像有类型不匹配的问题
    {
        while (appearCount != sizeB)
        {
            rear++;
            if (rear < sizeA)
            {
                auto iter = numbers.find(a[rear]);
                if (iter != numbers.end())
                {
                    if (count[(*iter).second] == 0)
                    {
                        appearCount++;
                    }
                    count[(*iter).second]++;
                }
            }
            else
            {
                break;
            }
        }
        while (appearCount == sizeB)
        {
            front++;
            auto iter = numbers.find(a[front]);
            if (iter != numbers.end())
            {
                count[(*iter).second]--;
                if (!count[(*iter).second])
                    appearCount--;
            }
        }
        if (rear - front + 1 < length)
        {
            resultFront = front;
            resultRear = rear;
            length = rear - front + 1;
        }
    }
    return vector<int>({ resultFront,resultRear, length });
  }
```
****
3. 给定两个整型数组a,b。每次可以将a或者b中的一个数+1或者-1。问最少经过多少次这样的操作，可以使a中的最大值小于b中的最小值？
* 思路：首先我们可以对两数组的合并数组进行一个排序，同时利用一个结构数组array进行存储，这个结构包含了存储的数以及该数的个数，以及所属的数组是a还是b。然后利用双指针。寻找到a的最大值所在的位置pos1，以及b的最小值所在的位置。然后比较pos1与pos2所在位置的数的个数count。count少的先动，以pos1先动为例，要移动到下一个不小于array[pos2].num并且属于a的位置posTemp，移动的位数自然就是array[pos1].count * (pos1-posTemp)，同时要改变array[posTemp].count，应加上array[pos2].num。当然，如果没能找到下一个要移动到的结点，我们就直接移动到pos2-1处就行了。接着把pos2移动到posTemp，重复判断，移动，并记录移动次数即可。
****
4. 给定两个字符串S,T。求S中包含T所有字符的最短连续子字符串的长度。

+ 思路：使用滑动窗口，一左一右，确保left在right的左边。首先得使用一个O(1)读写的结构存储T的字符及其出现的次数。然后再对S进行遍历，对于S中的字符S[i]，如果S[i]已经在T中出现过，则将其减去，如果减去后余量>=0，说明是有效的字符数量统计，则对已经出现的字符数目count+1，反之则说明实际该字符数量已经超标了，不对count + 1；如果当前的count已经和T的字符数目相等，就对左边的指针进行操作，首先是记录当前状态下的size和区间，然后左移left直至count != T.length()；

```c++
class Solution
{
public:
	string minWindow(string S, string T) {
		vector<bool> hasCharacter(26, false);
		vector<int> characterNum(26, 0);
        //使用26个字符的hash进行记录
		for(char c : T)
		{
			hasCharacter[c - 'A'] = true;
			++characterNum[c - 'A'];
		}
		int left = 0, right = 0, minSize = INT_MAX, targetCount = T.length(), currentCount = 0, subStringLeftIndex = -1;
		int size = S.length();
		while(right < size)
		{
			if (hasCharacter[S[right] - 'A'])
			{
				--characterNum[S[right] - 'A'];
				if (characterNum[S[right] - 'A'] >= 0)//如果是有余量的，则应正确计入
					++currentCount;
			}
			while(currentCount == targetCount)
			{
				if (right - left + 1 < minSize)
				{
					minSize = right - left + 1;
					subStringLeftIndex = left;
				}
				if (hasCharacter[S[left] - 'A'])
				{
					++characterNum[S[left] - 'A'];
					if (characterNum[S[left] - 'A'] > 0)//如果是有余量的，则应正确计入count的数量，否则视为数量超标
						--currentCount;
				}
				++left;
			}
			++right;
		}
		return minSize < INT_MAX?S.substr(subStringLeftIndex, minSize):"";
	}
};
```

****

5. [Leetcode_524]

    给定一个字符串 s ，找出至多包含 k 个不同字符的最长子串 T的长度。
   > 示例 1:
   > 输入: s = “eceba”, k = 2
   > 输出: 3
   > 解释: 则 T 为 “ece”，所以长度为 3。
   > 示例 2:
   > 输入: s = “aa”, k = 1
   > 输出: 2
   > 解释: 则 T 为 “aa”，所以长度为 2。
+ 思路：由于需要找子串，使用滑动窗口正好合适。要得到子串里面包含了多少不同的字符，得使用一个数据结构来存储之，而且要随着指针的滑动，能快速删减元素，而且，考虑到可能有多个相同元素的情况，可以使用关联式容器，建议hash，即unordered_map。每当right移动到一个新元素，首先判断该元素的引入是否导致超过k个不同的字符，如果不会，就把right - left + 1记录下来；否则，开始移动left，使得为不同字符回到k时，再继续移动right，直到right没法再移动为止。

```c++
class Solution {
public:
	int lengthOfLongestSubstringKDistinct(string s, int k) {
        int length = s.length();
        unordered_map<char, int> charMap;
        int totalCount = 0, left = -1, right = 0, maxLength = right - left, temp;
        while(right < length)
        {
            if (charMap.find(s[right])!= charMap.end())
            {
                ++charMap[s[right]];
                temp = right - left;
                if (temp > maxLength)
                    maxLength = temp;
                ++right;
			}//如果right的字符已经存在，则说明是重复的
            else if (totalCount < k)
            {
                charMap[s[right]] = 1;
                ++totalCount;
                temp = right - left;
                if (temp > maxLength)
                    maxLength = temp;
                ++right;
            }//如果right的字符不存在，且总字符数还是少于k种，则可以加入
            else
            {
                while(left < right)
                {
                    ++left;
                    if (charMap.find(s[left]) != charMap.end())
                    {
                        --charMap[s[left]];
                        if (charMap[s[left]] == 0)
                        {
                            charMap.erase(s[left]);
                            --totalCount;
                            break;
                        }//如果当前left的字符已经存在，则减掉一个，如果减掉之后字符数量为0了，则清空它，同时停止
                    }
                }//如果right的字符不能加入，则移动left
            }
        }
        return maxLength;
    }
};
```

****

6. [力扣42]\[接雨水问题]给定一个高度数组，求能积累的雨水量

+ 思路：
  + <font color = #00c040>关键点：对任何位置的点，它能积累的水量和它两侧的最高的柱子的较小值有关。</font>
+ 解法1:[动态规划]用两个数组记录每个柱子的左右侧的最高的柱子高度，再遍历一遍，得到总和
  + 时间复杂度：O(n)
  + 空间复杂度：O(n)


```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int size = height.size();
        if (size <= 2)
            return 0;
        int * leftMaxHeights = new int[size];
        int * rightMaxHeights = new int[size];
        leftMaxHeights[0] = 0;
        rightMaxHeights[size - 1] = 0;
        int result = 0;
        for(int i = 1; i < size; ++i)
        {
            leftMaxHeights[i] = max(leftMaxHeights[i - 1], height[i - 1]);
            rightMaxHeights[size - 1 - i] = max(rightMaxHeights[size - i], height[size - i]);
        }
        for(int i = 0; i < size; ++i)
        {
            result += max(0, min(leftMaxHeights[i], rightMaxHeights[i]) - height[i]);
        }
        delete [] leftMaxHeights;
        delete [] rightMaxHeights;
        return result;
    }
};
```

+ 解法2：[双指针]使用left和right指针，用leftMax，rightMax记录当前区间（left, right）的左右侧的最大高度。我们在移动left和right的同时会更新leftMax，rightMax。如果leftMax<rightMax，则说明左边已经可以确定要用leftMax来计算了，这样计算之后移动left指针；同理右边也一样，对于相等的情况，两个应当都要计算并且移动，由于要避免left=right导致计算两次的情况，所以循环条件设置为left < right
  + 时间复杂度：O(n)
  + 空间复杂度：O(1)

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int size = height.size();
        if (size <= 2)
            return 0;
        int left = 0, right = size - 1;
        int leftHighest = height[left], rightHighest = height[right];
        int result = 0;
        while(left < right)
        {
            if (height[left] > leftHighest)
                leftHighest = height[left];
            if (height[right] > rightHighest)
                rightHighest = height[right];
            if (rightHighest >= leftHighest)
            {
                result += (leftHighest - height[left]);
                ++left;
            }
            else if (rightHighest <= leftHighest)
            {
                result += (rightHighest - height[right]);
                --right;
            }
        }
        return result;
    }
};
```

+ 解法3：[单调栈]单调栈无非四种，递增的或者递减的，非升的或非降的。这里应当使用递减或者非升的。以递减的为例，首先可以入栈第一个元素。对于之后的元素，如果它符合递减的准则，就继续入栈，直到出现第一个不符合条件的元素，这时可以说明它至少是top元素的一个右边界，包括它等于top的情况。而top元素的一个左边界就是top之前入栈的元素。通过这个关系可以一层一层地求出水面高度。

```c++
class Solution{
public:
    int trap(vector<int>& height) {
        int size = height.size();
        if (size <= 2)
            return 0;
        stack<int> singleStack;
        singleStack.push(0);
        int result = 0, i = 1;
        while(i < size)
        {
            //小于就入栈
            if (height[i] < height[singleStack.top()])
            	singleStack.push(i++);
            //否则出栈一个元素，再看栈是否为空，即有无左边界，为空说明无法计算，只能把当前的压栈；不为空，则取出并进行计算
            else
            {
                int topHeight = height[singleStack.top()];
                singleStack.pop();
                if (!singleStack.empty())
                {
                    int left = singleStack.top();
                    result += (min(height[left], height[i]) - topHeight) * (i - left - 1);//计算这一层的水量
                }
                else
                {
                    singleStack.push(i++);
                }
            }
        }
        return result;
    }
};
```



### [递归与深度优先搜索]

1. 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例 1：
>输入：n = 3
>输出：["((()))","(()())","(())()","()(())","()()()"]
>示例 2：
>输入：n = 1
>输出：["()"]
* 思路：有关生成类的问题以及列出所有可能值的问题一般就涉及搜索算法，而搜索最主要的就是利用树的结构进行深度优先或者广度优先搜索。如果自己不想维护树，就一般使用递归算法。递归函数的递归出口写开头。
* 解法：
```C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> temp;
        //第一个必然是'('
        generateParenthesis(temp,n,"(",1,0);
        return temp;
    }
    void generateParenthesis(vector<string>&result,int n, string current, int leftNum, int rightNum)
    {
    	//左括号少于右括号数必然无效，直接出去。
        if (leftNum < rightNum || leftNum > n || rightNum > n)
        {
            return;
        }
        //左括号等于右括号数，且以及达到指定对数，则可以入列。同时也是递归出口
        if (leftNum == rightNum && leftNum == n)
        {
            result.push_back(current);
            return;
        }
        //否则要继续搜索。这里采用深度优先遍历。
        else{
            generateParenthesis(result,n,current + "(",leftNum+1,rightNum);
            generateParenthesis(result,n,current + ")",leftNum, rightNum+1);
        }
    }
};
```
****
### [单调栈]

#### 算法简述

+ 基本概念：单调栈分为单调递增栈和单调递减栈，以单调递增栈为例，遍历时，如果新元素比栈顶大，就入栈，反之，则一直出栈，直到栈为空或者栈顶元素小于新元素为止，再把新元素入栈。
+ 特性：
  + 元素是递增的
  + <font color = "red">在添加新元素时，如果栈顶元素出栈，则说明新元素是栈顶元素之后第一个比其小的元素，出栈后新的栈顶元素是出栈元素之前的第一个比它小的元素。</font>

+ <font color = "red">实质：使用O(n)复杂度，在一重遍历内确定每个元素前后最近的更大/更小元素的位置。</font>
+ 单调栈模板

```c++
stack<int> st;
for(int i = 0; i < nums.size(); ++i)
{
	while(!st.empty() && st.top() > nums[i])
	{
		st.pop();
	}
	st.push(nums[i]);
}
```

#### 相关题目

1. 有n个人站队，所有的人全部向右看，个子高的可以看到个子低的发型，给出每个人的身高，问所有人能看到其他人发现总和是多少。
* 思路：单调栈分为单调递增栈和单调递减栈，通过使用单调栈我们可以访问到下一个比他大（小）的元素。也就是说在队列或数组中，我们需要通过比较前后元素的大小关系来解决问题时我们通常使用单调栈。在这个题目中，一个人是否能看到另一个人的发型，需要比较两人之间的高度，当然还有阻挡的问题。既然有关高度比较，可以使用单调栈，对于元素a以及栈顶元素stack.top()，只有a<b才入栈，否则出栈继续比较，直到a<stack.top() || stack.empty()，这样，完事之后，count+=(stack.size() - 1)；
```C++
	int totalVisiableNum(vector<int> & heights)
	{
		stack<int> lowerStack({heights[0]});
		int i = 1, size = heights.size();
		int count = 0;
		while(i < size)
		{
			if(heights[i] < lowerStack.top())
			{
				count += lowerStack.size();
				lowerStack.push(heights[i++]);
			}
			else
			{
				while(heights[i] >= lowerStack.top() || !lowerStack.empty())
				{
					lowerStack.pop();
				}
				count += lowerStack.size();
				lowerStack.push(heights[i++]);
			}
		}
		return count;
	}
```

****

2. [力扣剑指offer. 84]柱状图中最大矩形

   给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

   求在该柱状图中，能够勾勒出来的矩形的最大面积。

   ![](Pictures/2.jpg)

+ 思路：一个朴素的做法是使用二重循环+暴力枚举，不断计算以i，j为区间的最大矩形面积，并一直维护这个矩形面积的最大值。然而时间复杂度是O(n<sup>2</sup>)。

  仔细思考，i到j之间的矩形的面积取决于这之中最矮的矩形，那么另一个做法则是，从0到n-1枚举中间某个柱子，并认为这个柱子是区间最矮的，然后再找边界，这个边界内的所有柱子应该不低于middle柱子，求出其左右边界，再计算以该柱子为最矮柱子得到的面积。然而时间复杂度依然是O(n<sup>2</sup>)。

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        int ans = 0;
        for (int mid = 0; mid < n; ++mid) {
            // 枚举最矮高
            int height = heights[mid];
            int left = mid, right = mid;
            // 确定左右边界
            while (left - 1 >= 0 && heights[left - 1] >= height) {
                --left;
            }
            while (right + 1 < n && heights[right + 1] >= height) {
                ++right;
            }
            // 计算面积
            ans = max(ans, (right - left + 1) * height);
        }
        return ans;
    }
};
```

​		在采用上述做法时，每枚举一个中间柱子，在求边界时实际就等价于是求middle左侧右侧第一个小于middle的位置，而根据单调栈push和pop的本质，使用递增的单调栈，实际push操作说明新元素是栈顶元素后第一个小于栈顶元素的，实际pop操作后，新栈顶元素是出栈元素前第一个小于出栈元素的。那么，完全可以在遍历时一边维护单调栈，一边计算左右边界。

```c++
class Solution {
public:
    int largestRectangleArea(vector<int> &heights)
    {
        stack<int> s;
        int ans = 0;
        heights.push_back(0);//加个0强制到最后时计算所有以rihgt为原size-1的情况
        for (int i = 0; i < heights.size(); ++i)
        {
            while (!s.empty() && heights[s.top()] >= heights[i])
            {
                int h = heights[s.top()];
                s.pop();
                if (s.empty())
                    ans = max(ans, i * h);
                else
                    ans = max(ans, (i - s.top() - 1) * h);
            }
            s.push(i);
        }
        return ans;
    }
};
```



****

### [优先队列]

1. 合并K个升序链表(力扣第23)

```C++
//优先队列：把所有的链表元素用小顶堆存储，然后再排出来即可
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() <= 0)
            return nullptr;
        ListNode * result = nullptr;
        ListNode * currentNode;
        priority_queue<int, vector<int>, greater<int>> tempQueue;
        for(auto iter = lists.begin(); iter != lists.end(); iter++)
        {
            ListNode* current = *iter;
            while(current)
            {
                tempQueue.push(current->val);
                current = current->next;
            }
        }
        if (!tempQueue.empty())
        {
            result = new ListNode(tempQueue.top());
            tempQueue.pop();
            currentNode = result;
        }
        while(!tempQueue.empty())
        {
            currentNode->next = new ListNode(tempQueue.top());
            tempQueue.pop();
            currentNode = currentNode->next;
        }
        return result;
    }
};
//分治法：用两个升序链表合并的方法，对其分治合并即可。
```
****
2. 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
+ 思路：使用两个栈，一个栈负责正常维护。另一个辅助栈则作为一个单调非降栈维护，对于这个辅助栈，每当要入栈新元素时，如果该辅助栈的端顶元素值大于它，则正常入栈它，否则就入栈一次端顶元素。出栈时，则同时出栈即可。
```c++
class MinStack {
    stack<int> thisstack;
    stack<int> minstack;
public:
    /** initialize your data structure here. */
    MinStack() {
        minstack.push(INT_MAX);
    }
    
    void push(int x) {
        thisstack.push(x);
        minstack.push(std::min(minstack.top(),x));
    }
    
    void pop() {
        thisstack.pop();
        minstack.pop();
    }
    
    int top() {
        return thisstack.top();
    }
    
    int min() {
        return minstack.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```

### [哈希表]

1. ![](pictures/哈希表1.png)

+ 思路：在考虑复制时，最容易想到顺序复制，但是顺序复制会发现有些random没法复制，所以得换种办法；由于对每个结点的操作都是复制，可以采用递归算法。
  + 因为每个原结点都对应一个新复制的结点，所以具体来说，可以使用哈希表unordered_map<Node * ，Node *>，当一个结点要进行复制时，如果哈希表里没有，则说明要复制，并加入哈希表，同时这个结点指向的next和random也是如此。故可以进行递归。最后返回哈希表里的新结点值
  + 对于边界情况，则是结点为空的情况为空直接返回nullptr即可

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    unordered_map<Node*, Node*> nodeMap;
    Node* copyRandomList(Node* head) {
        if (head == nullptr)
            return nullptr;
        if (!nodeMap.count(head))
        {
            Node * newHead = new Node(head->val);
            nodeMap[head] = newHead;
            newHead->next = copyRandomList(head->next);
            newHead->random = copyRandomList(head->random);
        }
        return nodeMap[head];
    }
};
```

****

### [树遍历]

1. 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

+ 思路：对于一棵二叉搜索树，它的中序遍历即可输出单调升序。那么我们可以利用它，首先是递归思路，我们进行深度优先遍历，当dfs(root->left)完成时，它会得到root的左边的结点pre，这时我们对pre进行判断，如果pre为空，说明当前root就是头结点，不需要处理连接，但是要把它记录成head；如果pre不为空，说明得到了root的左边结点，这时我们建立root和pre的连接，并将pre更新为root，再进行dfs(root->right)，就可以完成右边的遍历了。

 ```c++
 /*
 // Definition for a Node.
 class Node {
 public:
     int val;
     Node* left;
     Node* right;
 
     Node() {}
 
     Node(int _val) {
         val = _val;
         left = NULL;
         right = NULL;
     }
 
     Node(int _val, Node* _left, Node* _right) {
         val = _val;
         left = _left;
         right = _right;
     }
 };
 */
 class Solution {
 public:
     Node* treeToDoublyList(Node* root) {
         if(root == nullptr) return nullptr;
         dfs(root);
         head->left = pre;
         pre->right = head;
         return head;
     }
 private:
     Node *pre, *head;
     void dfs(Node* cur) {
         if(cur == nullptr) return;
         dfs(cur->left);
         if(pre != nullptr) pre->right = cur;
         else head = cur;
         cur->left = pre;
         pre = cur;
         dfs(cur->right);
     }
 };
 ```

****

### [排列问题]
1. 输入一个字符串，打印字符串的所有排列

* 思路：首先考虑递归办法，第0个位置有n个选择，第i个位置有n-i种选择。对于某个位置已经被选了的，就进行记录，防止再选，所以需要使用一个同样大小的标记数组。递归函数的作用就是确定第i个位置的元素。对于去重，则是如下操作，首先是对字符串排序，让相同的字符相邻。然后对于相同的字符a0，a1，仅当a0被选取时，才允许选择a1。不允许a0没选就选了a1，这样保证只有一个组合，不会重复

```c++
class Solution {
public:
    vector<string> rec;
    vector<int> vis;

    void backtrack(const string& s, int i, int n, string& perm) {
        if (i == n) {
            rec.push_back(perm);
            return;
        }//到了第n个时，说明已经获得了一个排列
        for (int j = 0; j < n; j++) {
            if (vis[j] || (j > 0 && !vis[j - 1] && s[j - 1] == s[j])) {
                continue;
            }
            vis[j] = true;
            perm.push_back(s[j]);
            backtrack(s, i + 1, n, perm);
            perm.pop_back();
            vis[j] = false;
        }
    }

    vector<string> permutation(string s) {
        int n = s.size();
        vis.resize(n);
        sort(s.begin(), s.end());
        string perm;
        backtrack(s, 0, n, perm);
        return rec;
    }
};
```

+ 思路2：先对s进行排序，然后每次获得下一个全排列即可

```c++
class Solution {
public:
    bool nextPermutation(string& s) {
        int i = s.size() - 2;
        while (i >= 0 && s[i] >= s[i + 1]) {
            i--;
        }
        if (i < 0) {
            return false;
        }//先找到一个位置，该位置的元素小于后面一个元素
        int j = s.size() - 1;
        while (j >= 0 && s[i] >= s[j]) {
            j--;
        }
        swap(s[i], s[j]);//从后面的元素中找一个最小的大于该元素的，并交换
        reverse(s.begin() + i + 1, s.end());
        //将该元素之后的进行排序，得到下一个排列
        return true;
    }

    vector<string> permutation(string s) {
        vector<string> ret;
        sort(s.begin(), s.end());//默认从小到大
        do {
            ret.push_back(s);
        } while (nextPermutation(s));
        return ret;
    }
};
```

****

### [对顶堆]
1. [剑指offer41] 维护数据流中的中位数
+ 思路：没啥好说的，直接对顶堆即可。注意好对顶堆的维护方法
```c++
class MedianFinder {
public:
    /** initialize your data structure here. */
    //对顶堆
    priority_queue<int> bigTopHeap;
    priority_queue<int, vector<int>, greater<int>> smallTopHeap;   
    void addNum(int num) {
        if (bigTopHeap.size() == 0 || num < bigTopHeap.top())
        {
            bigTopHeap.push(num);
        }
        else
            smallTopHeap.push(num);
        if (bigTopHeap.size() > smallTopHeap.size() + 1) smallTopHeap.push(bigTopHeap.top()), bigTopHeap.pop();
        if (smallTopHeap.size() > bigTopHeap.size() + 1) bigTopHeap.push(smallTopHeap.top()), smallTopHeap.pop();
        //如果不是求中位数，则改这里就行
    }
    
    double findMedian() {
        if ((smallTopHeap.size() + bigTopHeap.size())%2)
        {
            if (smallTopHeap.size() > bigTopHeap.size())
                return smallTopHeap.top();
            return bigTopHeap.top();
        }
        return (bigTopHeap.top() + smallTopHeap.top())/2.0;
    }
};
```

****

### [贪心算法]

#### 算法简述

+ 贪心算法主要在于从局部最优得到全局最优。基本问题如：区间问题，分配问题。贪心算法题也是需要最优子结构的，且往往快于动态规划。

+ 问题的关键在于如何度量最优。如何确定贪心策略。

  + 一般的问题都会涉及一个给定集合S。

    那么贪心策略可以是：

    + 在考虑子集合A时，在A的解达到最优时,能够使得S-A尽可能最优的策略。求达到最大，最多的时候可能要用。如：Leetcode_605
    + 在考虑子集合A时，能使得A达到最优的策略。每次扩大集合A时，都使得当前A达到最优。这颇有动规的感觉。如：Leetcode_452

+ 一些常用的思考方式：

  + 从局部出发，寻找一个较小集合，即基本情况下该如何求解。并迭代扩大集合，看如何演变。如:Leetcode_406

+ 一些常涉及的操作：
  + 按某个规律对集合排序
  + 记录区间，并排序

#### 相关题目

1. [LeetCode_605]假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

   给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。

+ 思路：先将flowerbed分成两个部分，一前一后，在前面可种植数已确定的情况下，前面的最后一个可种植位置越在前面，后面的可种植数量就更多。所以，这里的贪心策略就是：每次都使得该种植位置尽量靠左。让余下的部分有更多的可能。

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int size = flowerbed.size();
        if (size < 2 * n - 1)
            return false;
        int count = 0;
        for (int i = 0; i < size;)
        {
            if (flowerbed[i] == 0)
            {
                if (i == size - 1 || flowerbed[i + 1] == 0)
                {
                    count++;
                    i+=2;
                }
                else
                {
                    i++;
                }
            }
            else
                i+=2;
        }
        return count >= n;
    }
};
```

****

2.[LeetCode_452]假设有一堆气球，每个气球有左右边界，可能存在重叠，现在可以使用飞针刺穿之，对于重叠的气球，可以完全穿透，请问最少使用多少个针头可以全部刺穿？

+ 思路：首先判断问题类型，很明显，这里区间问题的气息浓厚，可能需要进行排序，不妨利用左边界升序排序好了。得到这个结果后，进行分析：我们知道，对气球i，引爆它最后的机会在它的右边界。那么如果按照区间顺序得到的第i +1个气球的右边界在气球i的左边，则我们可以同时击穿这两个气球，同时击穿的最后机会在i+1的右边界；如果i+1气球的右边界在i气球的右边，但i+1气球的左边界在其左边，则我们依然可同时击穿，击穿的最后机会在i的右边界；但如果i+1气球完全在i气球的右边，则无法同时击穿，只能多用一个刺针。

  这里的贪心策略在于：对于每个气球，我都找能击穿它的最右边的位置，看看在这之前能不能尽量击穿更多的气球。

```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), [](const vector<int>& a,const vector<int>& b){return a[0] < b[0];});
        int pos = points[0][1];//记录第1个气球的右边界
        int count = 1;
        for(const vector<int>& u : points)
        {
            if (u[1] < pos)
            {
                pos = u[1];
            }//如果下一个气球的右边界在其左边，我就移动到击穿这个气球的最后位置
            else if (u[0] > pos)
            {
                pos = u[1];
                count++;
            }//如果下一个气球的右边界在其右，且左边界也在其右，我就得多用一个针头了。前面这些击穿了，就移动到该气球的右边界，进行下一个循环。
        }
        return count;
    }
};
```

****

3. [Leetcode_406]假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
   请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

+ 思路：典型的从局部到整体的思路。首先看需不需要排序。也就是说看处理顺序的不同是否有很大影响，这要看处理集合迭代时的影响。设之前加入新加的元素为(x, y)，迭代集合时加入新加的元素为(a, b)

  + 如果a < x，那么原来处理的顺序都是不受影响的，因为它最矮，不改变之前处理的相对顺序，只要给(a, b)找空即可。
  + 如果a > x，那么只要b大于0，它就暂时找不到合适的位置。这说明处理顺序对其有影响。
  + 如果a == x && b > y，将新元素插入时，可以发现它也不改变原来结果的相对位置，它只要放在(x, y)的后面即可。
  + 如果a == x && b < y，将新元素插入时，它会放在(a, b)的前面，这意味着(a, b)可能会在不合适的位置上。

  既然发现不同的顺序会有不同的结果，那么就进行排序。高的在前，同高则ki小的在前。

  在排完序后，对一个新增的进行处理，因为里面已经排好的都是高度大于等于当前新增的元素的，所以只要根据ki就决定它在哪了。

  这里看不出啥贪心策略。只有局部到整体 + 看出顺序对处理决策的影响 + 排序后的解决办法

```c++
//用堆进行处理，注意堆的比较，greater表示小顶堆，因为堆顶放在最后一个元素，自定义得用伪函数
class Solution {
public:
    struct PeopleCompare
    {
        bool operator()(const pair<int,int>& pair1, const pair<int,int>& pair2)
        {
            return (pair1.first < pair2.first) || (pair1.first == pair2.first && pair1.second > pair2.second);
        }
    };//这是一个伪函数
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        vector<vector<int>> result;
        priority_queue<pair<int, int>, vector<pair<int,int>>, PeopleCompare> smallTopHeap;
        for(auto peopleInfo : people)
        {
            smallTopHeap.push(make_pair(peopleInfo[0],peopleInfo[1]));
        }
        while(!smallTopHeap.empty())
        {
            pair<int, int> topInfo = smallTopHeap.top();
            smallTopHeap.pop();
            Insert(result, topInfo);
        }
        return result;
    }

    void Insert(vector<vector<int>>& result,pair<int, int> topInfo)
    {
        bool hasInserted = false;
        int size = result.size();
        if (size == 0)
        {
            result.push_back({topInfo.first, topInfo.second});
            return;
        }
        auto iter = result.begin();
        int currentBiggerNum = 0;
        while(iter != result.end())
        {
            if (currentBiggerNum >= topInfo.second)
            {
                result.insert(iter,{topInfo.first, topInfo.second});
                return;
            }
            else
                currentBiggerNum++;
            iter++;
        }
        result.push_back({topInfo.first,topInfo.second});
    }
};

//改成sort排序，也差不多，复习下lambda
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        vector<vector<int>> result;
        sort(people.begin(),people.end(),[](vector<int>&people1, vector<int>&people2){return people1[0] > people2[0] || (people1[0] == people2[0] && people1[1] < people2[1]);});
        for(auto peopleInfo : people)
        {
            Insert(result,peopleInfo);
        }
        return result;
    }

    void Insert(vector<vector<int>>& result,vector<int>& topInfo)
    {
        int size = result.size();
        if (size == 0)
        {
            result.push_back({topInfo[0], topInfo[1]});
            return;
        }
        auto iter = result.begin();
        int currentBiggerNum = 0;
        while(iter != result.end())
        {
            if (currentBiggerNum >= topInfo[1])
            {
                result.insert(iter,{topInfo[0], topInfo[1]});
                return;
            }
            else
                currentBiggerNum++;
            iter++;
        }
        result.push_back({topInfo[0], topInfo[1]});
    }
};
```

****

4. [Leetcode_665]给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。

   我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。

+ 思路：首先这个数列没法动，也就没法排序

### [二分查找]

#### 算法简述

+ 二分：每次查找时将区间分成两部分，并进行剪枝，只取一部分继续查找。
+ 时间复杂度：
  + 最好O(1)
  + 最坏O(logn)
  + 平均O(logn)

+ 空间复杂度：
  + 迭代版本为O(1)
  + 递归(无尾调用消除，即函数最后是调用函数)版本是O(logn)


```c++
int binary_search(int start, int end, int key) {
  int ret = -1;  // 未搜索到数据返回-1下标
  int mid;
  while (start <= end) {
    mid = start + ((end - start) >> 1);  // 直接平均可能会溢出，所以用这个算法，值大于0时右移一般更快
    if (arr[mid] < key)
      start = mid + 1;
    else if (arr[mid] > key)
      end = mid - 1;
    else {  // 最后检测相等是因为多数搜索情况不是大于就是小于
      ret = mid;
      break;
    }
  }
  return ret;  // 单一出口
}
```

#### 最大值最小化

+ 所谓有序，可以是广义的概念，一个数组的一侧全满足某条件，而另一侧都不满足，也算有序。
+ 求解最大值最小化，可以使用<font color = "red">二分+剪枝</font>，并且对于这种问题，它一般都是NP完全问题。
  + 条件是答案在一个固定区间内
  + 查找一个答案比较难，但是能容易地判断值是否符合条件。
  + 可行解对于区间满足一定的单调性。即，若X合法，则X+1或者X-1也合法。

#### C++STL中的二分

+ std::lower_bound是查找首个不小于给定值的元素
+ std::upper_bound是查找首个大于给定值的元素
+ 见相关题目的第1题

#### 算法模板

****

##### 模板一

+ 特点：
  + 适用于最一般的查找，元素出现就返回，也是最普通的写法。
  + 使用≤进行循环判断
  + 判断middle的等于的情况

```c++
int search(vector<int>& nums, int target) {
    int size = nums.size();
    int left = 0, right= size - 1;
    while(left <= right)
    {
        int middle = left + ((right - left)>>1);
        if (nums[middle] == target)
        {
            return middle;
        }
        if (nums[middle] < target)
            left = middle + 1;
        else
            right = middle - 1;
    }
    return -1;
}
```

##### 模板二

```c++
int search(vector<int>& nums, int target) {
    int size = nums.size();
    int left = 0, right= size - 1;
    while(left < right)
    {
        int middle = left + ((right - left)>>1);//切记要打括号
        if (nums[middle] < target)
        {
            left = middle + 1;
        }
        else right = middle;
    }
    return nums[left]==target?left:-1;
}//用于查找第一次出现的位置
```

##### 模板三

```c++
int search(vector<int>& nums, int target) {
    int size = nums.size();
    int left = 0, right= size - 1;
    while(left < right)
    {
        int middle = (left + right + 1)>>1;//这个写法使得middle靠近right而不是left，相当于和上面那个完全相反
        if (nums[middle] <= target)
        {
            left = middle;
        }
        else right = middle - 1;
    }
    return nums[left]==target?left:-1;
}//用于查找最后一次出现的位置
```



#### C语言的二分与排序

+ bserach()二分查找
+ qsort()快速排序
  + void(void *ptr, size_t count, size_t size, * comp);
    + ptr: 表示按照升序给定的数组
    + count: 数组元素个数
    + size: 每个元素大小
    + comp:     int cmp(const void *a, const void\* b)

#### 相关题目

1. 给定一个**增序**的整数数组和一个值，查找该值第一次和最后一次出现的位置。

+ 思路：这实际相当于实现lower_bound和upper_bound函数

```c++
class Solution{
public:
    vector<int> serachRange(vector<int>& nums, int target)
    {
        if (nums.empty()) return vector<int>{-1,-1};
        int lower = Lower_Bound(nums, target);
        int upper = Lower_Bound(nums, target);
        if (lower == nums.size() || nums[lower] != target)
            return vector<int>{-1,-1};
        return vector<int>{lower, upper};
    }
    int Lower_Bound(vector<int>& nums, int target)
    {
        int left = 0, right = nums.size(),middle;
        while(left < right)
        {
            middle = left + ((right - left) >> 1);
            if (nums[middle] < target)
            {
                left = middle + 1;
            }
            else
            {
                right = middle;//注意不是middle - 1，因为对应<=的情况
            }
		}
        return left;
	}
    int upper_bound(vector<int> &nums, int target) {
	int l = 0, r = nums.size(), mid;
	while (l < r) {
	mid = l + ((r - l)>>1);
	if (nums[mid] > target) {
		r = mid;
	} 
    else {
		l = mid + 1;
	}
}
```
****

2. 给定一个原本增序数组的旋转数组nums，给定一个值target，查找target是否在nums中

+ 思路：对于一个旋转数组，必然可以分成两个非降序的部分。<font color = "red">而事实上，二分碰到非严格的数组时，往往需要进行适当的修改。</font>对于此题，如果采用二分搜索，nums[middle] < nums[right]时，判定为右侧增序，nums[middle] > nums[right]时，判定为左侧增序，同时也可以使用left一起判断；而存在nums[middle] == nums[right] == nums[left]的情况，这种情况下无法进行有效判断。这样只能让二分区间的左右边界同时缩窄，因为当nums[middle] == nums[right] == nums[left]的情况下，<font color = "red">缩窄边界。</font>必然有一方还是等于nums[middle]，另一方则不一定。

```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        int middle;
        while(left <= right)
        {
            middle = (left + right) / 2;
            if (nums[middle] == target)//循环出口写前面
                return true;
            if (nums[middle] == nums[right] && nums[middle] == nums[left])
            {
                --right;
                ++left;
            }
            else if (nums[middle] <= nums[right])//小于等于的情况
            {
                if (nums[middle] < target && nums[right] >= target)//这对于小于的情况，说明右边非降序，且target只可能在右边
                {
                    left = middle + 1;
                }//否则，右边可能非降序但target不在右边，也可能nums[middle] > target，这说明只能在左边
                else
                {
                    right = middle - 1;
                }
            }
            // nums[middle] > nums[right]的情况，也即左边非降序的情况
            else if (nums[middle] > target && nums[left] <= target)
            {
                right = middle - 1;
            }
            else
            {
                left = middle + 1;
            }
        }
        return false;
    }
};
```

+ 对于条件很多的，一定要写好条件判断，确保所有if-else块能包括所有情况

****

3. [极小化极大]\[力扣875]N堆香蕉，第i堆有piles[i]个，要在H小时内吃完，假设吃香蕉速度为K/h，每小时可以随便选一堆吃，如果数量少于k个，则这小时吃光它，不再吃其它的香蕉，否则就吃k个。求能吃完所有香蕉的最小k。

+ 思路：要求出所有可行解，很麻烦，但对于每个值，都可以验证，而且如果某个k不足，则至少答案在k之上，如果k足够了，则k以上的都行。这样，可以转换成一个二分查找。

```c++
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int low = 1, high = INT_MAX;
        int middle = low + ((high - low)>>1);
        // 使用INT_MAX，最多30次回到最小值1
        while(low < high)
        {
            if (!CanEatOut(piles, middle, h))
                low = middle + 1;
            else
                high = middle;
            middle = low + ((high - low)>>1);
            //一个二分
        }
        return middle;
    }
    bool CanEatOut(vector<int>& piles, int perEatNum, int time)
    {
        int size = piles.size();
        int result = 0, i = 0;
        while(i < size)
        {
            int temp = piles[i];
            result += temp/perEatNum;
            if (temp%perEatNum)
                result++;
            if (result > time)
                return false;
            ++i;
        }
        return true;
    }
};
```

****

4. [极小化极大]\[力扣2064]

   给你一个整数 `n` ，表示有 `n` 间零售商店。总共有 `m` 种产品，每种产品的数目用一个下标从 **0** 开始的整数数组 `quantities` 表示，其中 `quantities[i]` 表示第 `i` 种商品的数目。

   你需要将 **所有商品** 分配到零售商店，并遵守这些规则：

   - 一间商店 **至多** 只能有 **一种商品** ，但一间商店拥有的商品数目可以为 **任意** 件。
   - 分配后，每间商店都会被分配一定数目的商品（可能为 `0` 件）。用 `x` 表示所有商店中分配商品数目的最大值，你希望 `x` 越小越好。也就是说，你想 **最小化** 分配给任意商店商品数目的 **最大值** 。

   请你返回最小的可能的 `x` 。

+ 思路：和上题差不多，略。

```c++
class Solution {
public:
    int minimizedMaximum(int n, vector<int>& quantities) {
        int low = 1, high = INT_MAX;
        int middle = low + ((high - low)>>1);
        while(low < high)
        {
            if (CanSolve(quantities, n, middle))
            {
                high = middle;
            }
            else
            {
                low = middle + 1;
            }
            middle = low + ((high - low)>>1);
        }
        return middle;
    }
    bool CanSolve(vector<int>& quantities, int n, int maxNum)
    {
        int result = 0, i = 0, size = quantities.size();
        while(i < size)
        {
            int temp = quantities[i];
            result += temp/maxNum;
            if (temp%maxNum)
                ++result;
            if (result > n)
                return false;
            ++i;
        }
        return true;
    }
};
```



### [排序算法]

#### 算法描述

+ 快速排序
+ 时间复杂度：
  + 平均：O(nlogn)  
  + 最好O(nlogn) 序列总是均分成两个子序列
  + 最坏:O(n<sup>2</sup>)  每次都搜到另一头，也就是数组正好反序
+ 空间复杂度:O(logn)
+ 稳定性：不稳定

```c++
class Solution
{
public:
	void quick_sort(vector<int>& nums, int left, int right)
	{
		if (left + 1>= right)
			return;
		int leftIndex = left, rightIndex = right - 1, value = nums[leftIndex];
		while(leftIndex < rightIndex)
		{
			while(leftIndex < rightIndex && nums[rightIndex] >= value)
			{
				--rightIndex;
			}
			nums[leftIndex] = nums[rightIndex];
			while(leftIndex < rightIndex && nums[leftIndex] <= value)
			{
				++leftIndex;
			}
			nums[rightIndex] = nums[leftIndex];
		}
		nums[leftIndex] = value;
		quick_sort(nums, left, leftIndex);
		quick_sort(nums, leftIndex + 1, right);
	}
};
//快排的参数left，right表示考虑[left, right)下标内的元素
```

+ 快排的优化策略
  + 枢纽元：枢纽元是指当前要排的数。

  + 选取策略：

    + 最普通的选取是选择第一个或者最后一个元素作为枢纽元
    + 随机选取：从left到right中随机取index，将nums\[index]作为当前枢纽元
    + <font color = "red">三数取中法</font>：将nums\[left]、nums\[right]、nums[(left + right)/2]的中位数作为选取的值。实际减少了14%的比较

  + 优化策略：

    + <font color = "red">当数组大小较小时，转用插入排序。</font>一般可以取n = 5到12，改用插入排序

    + <font color = "red">聚集元素</font>

      例子：1 4 6 7 <font color ="red">6</font> 6 7 6 8 6

      三数取中，为6，将其与1交换

      <font color = "red">6</font> 4 6 7 1 6 7 6 8 6

       ↑                             ↑

      

#### 相关题目

1. [TOP-K问题，力扣215]求数组中第k大的数

```c++
// 方法1 O(nlogn)与O(n^2)，取决于排序算法的选取 排序后第k-1个元素
// 方法2 O(n^2) 
```

****

2. [力扣2199、剑指offer51. 数组中的逆序对(归并排序、前缀和)]

   在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

+ 思路：求逆序对，我们很容易想到基于比较的排序。于是第一种方法就是采用归并排序，归并排序是一种典型的分治算法，它会首先通过递归将数组分割成只有2个元素大小的单元，并进行比较排序，然后再变成两个排好序的2元素大小数组，排序成有序列表。只要我们在数组排序成从小到大的过程中进行记录即可。
+ 复杂度分析：时间复杂度:O(nlogn),空间复杂度:O(n)

```c++
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        int size = nums.size();
        vector<int> temp(size, 0);
        return mergeSort(nums, temp, 0, size - 1);	//归并排序需要一个辅助数组，假设采用闭区间
    }
private:
    int mergeSort(vector<int>&nums,vector<int>& temp, int left, int right)
    {
        if (left >= right)
            return 0;								//大小为1则无需排序，是递归出口
        int middle = left + ((right - left)>>1);	//取中值切分
        int totalResult = mergeSort(nums, temp, left, middle) + mergeSort(nums, temp, middle + 1, right);
        											//进行递归
        int leftPtr = left, rightPtr = middle + 1, index = left;
        while(leftPtr <= middle && rightPtr <= right)
        {
            if (nums[leftPtr] <= nums[rightPtr])
            {
                temp[index++] = nums[leftPtr];
                totalResult += (rightPtr - middle - 1);
                leftPtr++;							//对前面归并完成的两部分之间的进行统计
                								//左边的小，要插入数组，说明它大于已经在数组内的来自右边部分的数
            }
            else
            {
                temp[index++] = nums[rightPtr];
                rightPtr++;
            }
        }
        while(leftPtr <= middle)
        {
            temp[index++] = nums[leftPtr++];
            totalResult += (right - middle);	//同上
        }
        while(rightPtr <= right)
        {
            temp[index++] = nums[rightPtr++];
        }
        copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);
        										//将排序结果写回nums
        return totalResult;
    }
};
```

+ 思路2：

### [回溯]

#### 算法描述

#### 相关题目

1. 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。

   candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 

   对于给定的输入，保证和为 target 的唯一组合数少于 150 个。

+ 思路：这种组合问题，一个数既可以选，也可以不选，那么可以得到一棵树，说明可以考虑回溯法，而回溯，则常常使用深度优先。如果不选择candidates[i]，则target不变，下标移动到i + 1，如果选择candidates[i]，则target -= candidates[i]，下标不变，因为可以重复。

```c++
class Solution {
public:
    void dfs(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& combine, int idx) {
        if (idx == candidates.size()) {
            return;
        }
        if (target == 0) {
            ans.emplace_back(combine);
            return;
        }
        // 直接跳过
            dfs(candidates, target, ans, combine, idx + 1);
        // 选择当前数
        if (target - candidates[idx] >= 0) {
            
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector<vector<int>> ans;
        vector<int> combine;
        dfs(candidates, target, ans, combine, 0);
        return ans;
    }
};
```

****

2. 给定一个二维字符网格board，和一个字符串，看是否存在相邻的字符使得word在网格中

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int row = board.size();
        int coloumn = board[0].size();
        
        // 记住这种写法
        vector<vector<bool>> tick(row, vector<bool>(coloumn, false));
        for (int i = 0; i < row; ++i)
            for (int j = 0; j < coloumn; ++j)
            {
                if (hasString(board, i, j, row, coloumn, word, 0, tick))
                    return true;
            }
        return false;
    }

    bool hasString(vector<vector<char>>& board, int i, int j, int row, int coloumn, string& word, int index, vector<vector<bool>> &tick)
    {
        static vector<pair<int, int>> directions = {{1,0},{-1,0},{0,1},{0,-1}};
        if (board[i][j] != word[index])
            return false;
        tick[i][j] = true;
        if (index == word.length() - 1)
            return true;
        for(const auto &direction : directions)
        {
            int newI = i + direction.first;
            int newJ = j + direction.second;
            if (newI >= 0 && newI < row && newJ >= 0 && newJ < coloumn && !tick[newI][newJ])
            {
                if (hasString(board, newI, newJ, row, coloumn, word, index + 1, tick))
                    return true;
            }
        }
        tick[i][j] = false;
        return false;
    }
};
```

### [LIS问题]
+ 问题描述：求一个序列的最长递增子序列/最长非降子序列
+ 问题解法：
  + dp算法   O(n<sup>2</sup>)
  + <font color = "red">二分+贪心   O(nlogn)</font>

```c++
// dp法
class Solution
{
    int longestIncreasingSequence(vector<int>& nums)
    {
        int size = nums.size();
        int result = 0;
        vector<int> dp(size, 1);
        for (int i = 0; i < size; ++i)
        {
            for (int j = i - 1; j >= 0; --j)
            {
                if (dp[i] > dp[j])
                	dp[i] = max(dp[i], dp[j] + 1);	//若是非降，则改成>=
            }
            result = max(result, dp[i]);
        }
        return result;
    }
}


// 二分+贪心法
// 基本思想：对于已经得到的序列而言，它的最后一个元素越小，越有利于后续得到更长的序列，于是维护好已经得到的数组即可。
// 注意这种只适合求个数，如果要求序列，还是上面那个吧
// 以[1, 7, 3, 5, 9, 4, 8]为例
// ①[1]
// ②[1, 7]
// ③[1, 3]
// ④[1, 3, 5]
// ⑤[1, 3, 5, 9]
// ⑥[1, 3, 4, 9]
// ⑦[1, 3, 4, 8]
// 那么就是4了
class Solution
{
    int longestIncreasingSequence(vector<int>& nums)
    {
        int size = nums.size();
        int *sequenceStack = new int[size];
        int top = -1;
        for (int x : nums)
        {
            if (top == -1 || x > sequenceStack[top])
            {
                sequenceStack[++top] = x;
            }
            else
            {
                int left = 0, right = top;
                while(left <= right)
                {
                    int middle = left + ((right - left)>>1);
                    if (nums[middle] <= x)
                    {
                        left = middle + 1;
                    }
                    else
                    {
                        right = middle;
                    }
                }
            }
        }
    }
}
```



