

# 算法题 #

### [基本的输入输出]
```c++
#include<bits/stdc++.h>

// cin >> val;
//这种遇到结束符就会结束，但第一个输入的时候会自动忽略前面的结束符(tab，\n, space)
int x, y;
cin >> x >> y;

// cin.get(字符数组名，接收长度，结束符)
// 长度应该为数组size - 1
// 遇到结束符就停止，这个结束符还在流里面

// cin.get(c)
// 等价于 char c = cin.get();


// cin.getline(字符数组名，接收长度，结束符)
// 遇到结束符就停止，且流里面的结束符抛弃

// getline(istream is, string str, 结束符)
string str;
int temp;
getline(cin, str);
stringstream ss(str);
while(ss >> temp)
{
    ...;
}

//上面的结束符都是可选参数
```

### [数学题]

1. [洗牌算法]给n个数，随机输出m个不同的数
	解法：
```c++
void knuth(vector<int>nums, int m)  
{  
    srand((unsigned)time( NULL));
    int n = nums.size();
    for( int i = 0; i < n; i++)  
    {  
        if( rand()%(n-i) < m)  
        {  
            cout << i << "\t";  
            m--;  
        }
    }
    return;  
}
```
* 随着i的不断增大，rand()%(n-i)会不断减小，最后一定能随机地输出这m个数

2. [剑指offer 56]一个int数组，除了两个数字以外，其它数字都出现了2次，求出这两个只出现1次的数字。

+ 思路：之前有个题，是只有一个数字只出现一次，其余出现2次，采用的是直接全部异或的办法，最终就能得到答案。而这个题，可以采取分组异或的办法，如果能让这两个数字出现在不同的分组里，且其它相同的数字会分在相同分组，那么就转换成之前的那个问题了。首先全部异或，得到的最终应该是result = x^y，假设这个结果的第i位为0，则表示x和y的第i位相同，为1，则表示两者第i位不相同。于是我们可以任意选择result的一个为1的bit作为划分条件，对于其它出现两次的数k，k与这个0000100000（假设是这个）异或会得到相同的结果，就分在同一个组，而对于x，y这两个只出现一次的，则会在这组上呈现不同，进而分到不同的组去。于是便完成了分组，最后就只要各自异或就可以得到答案了。

  ```c++
  class Solution {
  public:
      vector<int> singleNumbers(vector<int>& nums) {
          int result = 0;
          for (int val : nums)
              result ^= val;
          int i = 1;
          while((result & i) == 0)
              i <<= 1;
          int left = 0, right = 0;
          for (int val : nums)
          {
              if ((val & i) == 0)
                  left^=val;
              else
                  right^=val;
          }
          return {left, right};
      }
  };
  ```

3.[剑指offer56]数组中数字出现的次数。

​	有个数组nums中除了一个数字出现1次以外，其余的都出现三次，找出这个数字

+ 思路：这个题目的做法可以认为是这一类题目的通用做法。我们对nums内的每个数字进行处理，统计每一个二进制位，它如果为1，则对应计数+1。全部处理完毕，再对所有二进制位取3的余数，剩下的就是只出现1次的这个数所拥有的二进制位了。

  ```c++
  class Solution {
  public:
      int singleNumber(vector<int>& nums) {
          vector<int> bits(32, 0);
          for (int val : nums)
          {
              int x = 1;
              for (int i = 0; i < 32; ++i)
              {
                  if (val & x)
                      ++bits[i];
                  val >>= 1;
              }
          }
          int j = 1;
          int result = 0;
          for (int k = 0; k < 32; ++k)
          {
              bits[k]%=3;
              if (bits[k]){
                  result += j << k;
              }
          }
          return result;
      }
  };
  ```
4. \[剑指offer62][约瑟夫环,递归]给定n，m。从0到n-1的n个数字组成的环中每次删除第m个，问最后剩下谁。如0,1,2,3,4。每次删第三个，则依次删除2,0,4,1，最后剩下3

+ 思路：f(m, n)表示答案的解，那么我们知道，第一次删除的数字必然是(m - 1)%n，这下剩了n-1个数字，如果而对于f(m, n - 1)，如果已知答案它的子问题的答案是x，则说明应该是(m + x)%n。所以只要递归就行。

  ```c++
  class Solution {
      int f(int n, int m) {
          if (n == 1) {
              return 0;
          }
          int x = f(n - 1, m);
          return (m + x) % n;
      }
  public:
      int lastRemaining(int n, int m) {
          return f(n, m);
      }
  };
  ```

5. [力扣169]多数元素。给定一个vector\<int>。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

+ 思路：
  + 哈希：统计每个元素出现的次数，最后返回出现次数最大的即可。时间空间复杂度均为O(n)
  + 排序：排序后下标⌊ n/2 ⌋的元素必然是该多数元素。复杂度看使用的算法，时间复杂度可以是O(nlogn)，如果是使用sort，它使用的快速排序就是O(logn)的栈空间
  + 分治：既然有元素大于⌊ n/2 ⌋个，那么分成两半，该元素也必然是某一个部分的多数元素。当然，如果两边的多数元素不同，那就得比较哪个数量大，进而确定谁是多数元素了。时间复杂度为O(nlogn)，空间复杂度为O(logn)
  + Boyer-Moore：如果把众数记作+1，其它的记作-1。那么把元素加和，必然大于1。如此，可以记录加和的结果count以及候选的众数candidate，遍历一遍数组。
    + 在遍历时，如果count == 0，则将元素赋值给candidate
      + 如果candidate == val，则count += 1
      + 否则count -= 1
    + 这样，在最后的这个candidate必然就是众数。因为其他的数字的数量之和少于众数的数量

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate, count = 0;
        for (int val : nums)
        {
            if (count == 0)
                candidate = val;
            if (val == candidate)
                ++count;
            else
                --count;
        }
        return candidate;
    }
};
```

****
### [动态规划]

#### 算法简述

+ 动态规划实际就是有记忆的递归。可用动态规划的问题常常需要有最优子结构。
+ 常见的动态规划的做法：
  + 使用一维的dp[i]
    + 仅包含前i个元素时问题的解，以求得dp[i + 1]
    + 表示以dp[i]结尾的解，这个往往是临时结果，一般都要求最大的值
  + 使用二维dp\[i][j]
    + 表示从nums[i]到nums[j]这一个区间内问题的解
    + 当然还有其它表示，比如常见的背包问题
+ 注意点：
  + 对于二维dp，常常需要根据转移方程和可以达成的初始条件好好考虑求解顺序。

#### 相关问题

1. [力扣368]最大整除子集：给定一个非负数组，定义整除集如下：集合内所有元素都满足整除关系。求该数组的最大整除子集。
	解法：

   ```c++
   vector<int> largestDivisibleSubset(vector<int>& nums) {
    int size = nums.size();
    vector<vector<int>> dp(nums.size(), vector<int>(2));   
    // 定义一个二维数组，第一维表示以nums[i]结尾的最大整除子集的大小；
    //第二维表示该元素的前缀
    for (vector<int> &element : dp)
    {
        element[0] = 1;
        element[1] = -1;
    }
    int maxIndex = 0;
    for (int i = 1; i < size; i++)
    {
        for (int j = i - 1; j >= 0; j--)
        {
            if (nums[i] % nums[j] == 0 && dp[j][0] + 1 > dp[i][0]) 
            {
                dp[i][0] = dp[j][0] + 1;
                dp[i][1] = j;
                if (dp[i][0] > dp[maxIndex][0])
                {
                	maxIndex = i;
                }
            }
        }
    }
    vector<int> result;
    int m = maxIndex;
    while(m != -1)
    {
        result.push_back(nums[m]);
        m = dp[m][1];
    }
	 sort(result.begin(), result.end());
	 return result;
	}
	```
	
	****
	
2. 有台奇怪的打印机有以下两个特殊要求：打印机每次只能打印由 同一个字符 组成的序列。每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。
* 思路：对于s[i] == s[j]的情况,dp [i] [j] = dp [i] [j-1].对于s[i] !=s[j]的情况，则要分成两部分打印，从i打印到k，再从k+1打印到j。k取值在i+1到j-1范围内，选择dp[i] [k] + dp [k+1] [j]之和最小的

* 解法：
```c++
      int strangePrinter(string s) {
          int n = s.length();
          vector<vector<int>> f(n, vector<int>(n));
          for (int i = n - 1; i >= 0; i--) {
              f[i][i] = 1;
              for (int j = i + 1; j < n; j++) {
                  if (s[i] == s[j]) {
                      f[i][j] = f[i][j - 1];
                  } else {
                      int minn = INT_MAX;
                      for (int k = i; k < j; k++) {
                          minn = min(minn, f[i][k] + f[k + 1][j]);
                      }
                      f[i][j] = minn;
                  }
              }
          }
          return f[0][n - 1];
      }
  
```
****
3. 你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：要求每首歌至少播放一次。一首歌只有在其他 K 首歌播放完之后才能再次播放。

* 思路：设dp [i] [j]表示长度为i的歌单里恰有j首不同歌曲的情况。则有如下转移关系。前者表示第i首为新歌的情况，后者表示为老歌的情况，后者当k不为0时，表明第i首歌的前面k首都不能与第i首歌相同，且这些歌彼此也不会相同，直接排除了k首。
```c++
dp [i] [j] = dp [i-1] [j-1] * (N - j + 1) + dp [i - 1] [j] * (max(j - k, 0));
```
* 解法：
```c++
	int numMusicPlaylists(int N, int L, int K) {
        //dp[i][j]表示总共听了i首歌的情况下,且一共有j首不同的歌.对应的播放方法数
        //优化后可以去掉i的维度
        long mod = 1000000007;
        vector<long> dp(N+1,0);
        dp[1] = N;  
        for(int i = 2 ; i <= L ; ++i){
            for(int j = min(i,N) ; j > 0 ; --j){
                dp[j] = (dp[j-1] * ( N - j + 1) + dp[j] * (j > K ? j - K : 0) + mod) % mod;
            }
        }
        return dp[N];
    }
```
****
4. 有两个整型数组a,b。将a，b中相同的元素一一连起来，并保证线与线之间不交叉，请问最多有多少条这样的线？

```C++
/*动态规划：设一个dp二维数组,m*n。对于dp[i][j]，其表示a的前i个元素和b的前j个元素所具有的最多的线的个数。
那么对于dp[i][j]的值，分为两种情况：
1.当a[i] == b[j]时，dp[i][j] = dp[i - 1][j - 1]
2.当a[i] != b[j]时，dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
最后留意边界情况即可。*/
class Solution
{
public:
    int getLinesNum(vector<int>& a, vector<int> b)
    {
        int sizeA = a.size();
        int sizeB = b.size();
        int dp[sizeA][sizeB];
        if(a[0] == b[0])
        {
            dp[0][0] = 1;
		}
        else dp[0][0] = 0;
        for (int i = 1; i < sizeB; i++)
        {
            if ((dp[0][i - 1] != 1 && b[i] == a[0]) || dp[0][i - 1] == 1)
            {
                for(int k = i; k < sizeB; k++)
                {
                    dp[0][k] = 1;
				}
                break;
            }
            else
                dp[0][i] = 0;
		}
        for (int i = 1; i < sizeA; i++)
        {
            if ((dp[i - 1][0] != 1 && b[0] == a[i]) || dp[i - 1][0] == 1)
            {
                for(int k = i; k < sizeA; k++)
                {
                    dp[k][0] = 1;
				}
                break;
            }
            else
                dp[i][0] = 0;
		}
        for (int i = 1; i < sizeA; i++)
        {
            for (int j = 1; j < sizeB; j++)
            {
                if (a[i] == b[j])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
		}
        return dp[sizeA - 1][sizeB - 1];
	}
}
```
****
5. 假设有多个区间序列，请找到一个数，使得它所在的区间的个数最大

+ 思路：对于每个区间a,++dp[a[0]]，--dp[a[1]]，得到dp[i]的一系列值，最后计算得到前j个之和最大的点即可

****

6. [哈希，力扣1218  最长定差子序列]给定一个整数数组arr和一个整数difference，找出并返回arr中最长等差子序列长度，该序列中相邻元素之间的差等于difference

   + 思路：首先可以按照动态规划的思路，先从一维考虑。dp[i]可以表示以arr[i]结尾的最长序列的长度。那么对于其求解，可以得到dp[i] = dp[r] + 1，其中arr[r]应等于arr[i] - difference，如果找不到这样的r，则dp[i] = 1。至此可以求解。

     <font color = "red">对于这种求dp[i]要遍历前面所有元素以找到指定元素的，可以利用哈希表进行优化</font>

```c++
class Solution {
public:
    int longestSubsequence(vector<int>& arr, int difference) {
        int size = arr.size();
        unordered_map<int, int> dp;
        // 使用哈希表优化
        int result = 0;
        for(int v : arr)
        {
            dp[v] = dp[v - difference] + 1;
            // 对于不存在的键，其值默认全0
            result = max(result, dp[v]);
        }
        return result;
    }
};
```

7. [剑指offer63.股票的最大利润]给定一个数组表示股票价格，仅买卖一次股票，求最大收益。若是多次买卖呢？多次买卖就贪心。

+ 思路：根据股票价格得到后一天的价格相对前一天的涨跌值，然后就是LIS问题

  ```c++
  class Solution {
  public:
      int maxProfit(vector<int>& prices) {
          int minprice = INT_MAX, maxprofit = 0;
          for (int price : prices) {
              minprice = min(price, minprice);
              maxprofit = max(maxprofit, price - minprice);
          }
          return maxprofit;
      }
  };
  ```


8. [力扣139]单词拆分，给定一个单词string，和一个字典vector\<string>，判断是否可以用字典里面的单词组成string，可以重复使用。

+ 设dp[i]表示前i个字母组成的单词能否用字典里面的单词组成，则dp[i] = dp[j] + canMakeIt(string[j + 1,.....,i])。这个字典可以换成一个哈希表。于是就可以使用动态规划了。

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dic(wordDict.begin(), wordDict.end());
        int length = s.length();
        vector<bool> dp(length + 1);
        dp[0] = true;
        for (int i = 1; i <= length; ++i)
        {
            dp[i] = false;
            for (int j = 0; j < i; ++j)
            {
                if (dp[j] && dic.count(s.substr(j, i - j)) != 0)//s.substr(beginIndex, num);构造字符串子串
                {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[length];
    }
};
```

9. [力扣152]求乘积最大连续子数组的乘积。

+ 思路：简单地知道，这和最大连续子数组是一类问题。于是可以设置dp[i]表示以下标i结尾的最大的乘积。需要注意的是，乘积可以是负数乘以负数，所以，既需要记录以i结尾的最小的乘积，也要记录最大的。

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int size = nums.size();
        vector<int> dp1(size, 0);
        vector<int> dp2(size, 0);
        int maxResult = nums[0];
        dp1[0] = nums[0];
        dp2[0] = nums[0];
        for (int i = 1; i < size; ++i)
        {
            dp1[i] = max({nums[i], dp1[i - 1] * nums[i], dp2[i - 1] * nums[i]});
            dp2[i] = min({nums[i], dp1[i - 1] * nums[i], dp2[i - 1] * nums[i]});
            maxResult = max(dp1[i], maxResult);
        }
        return maxResult;
    }
};
```

10. [力扣279]完全平方数

    给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

    完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

+ 思路：看到这一般就想到使用动态规划了，以dp[i] = min(dp[i - j*j]) + 1，就行

```c++
class Solution {
public:
    int numSquares(int n) {
        int edge = sqrt(n);
        vector<int> dp(n + 1);
        dp[0] = 0;
        for (int i = 1; i <= n; ++i)
        {
            int minNum = INT_MAX;
            for (int j = 1; j * j <= i; ++j)
            {
                minNum = min(dp[i - j * j], minNum);
            }
            dp[i] = minNum + 1;
        }
        return dp[n];
    }
};
```

11. [力扣5]最长回文子串

+ 思路1：动态规划。记录dp[i]\[j]为i到j是否为回文串，则dp[i]\[j] = dp[i + 1]\[j - 1] && s[i] == s[j]。容易发现，应当从下往上填空，且由于在对角线右上的第一个元素会用到对角线以下的tick，即两个元素的时候的判断，我们知道这时只要判断s[i] == s[j]，所以应当把所有的都设置为true

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int length = s.length();
        if (length < 2)
            return s;
        vector<vector<bool>> dp(length, vector<bool>(length, true));
        int maxLength = 1, start = 0;
        for (int i = length - 2; i >= 0; --i)
        {
            for (int j = i + 1; j < length; ++j)
            {
                if (dp[i + 1][j - 1] && s[i] == s[j])
                {
                    dp[i][j] = true;
                    if (j - i + 1 > maxLength)
                    {
                        maxLength = j - i + 1;
                        start = i;
                    }
                }
                else
                    dp[i][j] = false;
            }
        }
        return s.substr(start, maxLength);
    }
};
```

+ 思路2：中心扩展。不断枚举每个字符，认为是中间字符，然后向两边扩展，当然需要考虑这个子字符串是奇数个还是偶数个的。

```c++
class Solution {
public:
    pair<int, int> expand(string& s, int left, int right)
    {
        while(left >= 0 && right < s.length() && s[left] == s[right])
        {
            --left;
            ++right;
        }
        return {left + 1, right - 1};
    }
    string longestPalindrome(string s) {
        int length = s.length();
        if (length < 2)
            return s;
        int maxLength = 1, startPos = 0;
        for (int i = 0; i < length; ++i)
        {
            auto [start, end] = expand(s, i, i);
            if (end - start + 1 > maxLength)
            {
                maxLength = end - start + 1;
                startPos = start;
            }
            auto [start1, end1] = expand(s, i, i + 1);
            if (end1 - start1 + 1 > maxLength)
            {
                maxLength = end1 - start1 + 1;
                startPos = start1;
            }
        }
        return s.substr(startPos, maxLength);
    }
};
```



### [双指针与滑动窗口]

#### 算法简述

+ **双指针**：主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多 个数组的**多指针**。

+ **滑动窗口**：若两个指针指向同一数组，遍历方向相同且不会相交，则也称为**滑动窗口**（两个指针包围的区域即为当前的窗口），经常用于**区间搜索求最值**，比如**快慢指针**。 若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。这常用于解决字符串的子串问题

+ 一些典型问题
  + 接雨水：遍历方向相反的双指针。
  
  + 归并两个有序链表：一般的双指针
  
  + 检测单链表有无环：遍历方向相同的快慢指针。如果要找到环路的开始点，则在两指针相遇时，把快指针重置到头结点，接着使用和慢指针一样的速度前进，再次相遇的点即为环路的开始点。
  
  + 求包含t元素的s的最长 / 最短子串
  
    ```c++
    // 一般有这样的统一的做法，这种题常常要用map记录滑动窗口内的元素及其个数
    bool check();
    bool findRes(string& s, string t)
    {
        map<char, int> cnt;
        int left = 0, right = 0;
        while(right < s.length())
        {
            ++cnt[s[right]];
            while(check())
            {
                {
                    // 记录结果
                }
                --cnt[s[left++]];
            }
        }
    }
    ```
  
    

#### 相关题目

1. 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。

+ 思路：我们设置一个滑动窗口，这意味着有一个左指针，一个右指针。我们希望指针范围内能表示一个无重复的子串，这样就可以通过左右指针的位置right - left + 1得到子串长度。要做到这点，意味着每次加入的字符必须是没出现过的，在它加入前，必须确保它不存在，如果窗口中有它，就得滑动边界让它滑出窗口。就可以使用一个unordered_set来记录窗口内的元素

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int length = s.length();
        int left = 0;
        int maxLength = 0;
        unordered_set<char> membersInSlidingWindow;
        for (int right = 0; right < length;++right)
        {
            while(membersInSlidingWindow.count(s[right]) != 0)
            {
                membersInSlidingWindow.erase(s[left++]);
            }
            membersInSlidingWindow.insert(s[right]);
            maxLength = max(maxLength, right - left + 1);
            membersInSlidingWindow.insert(s[right]);
        }
        return maxLength;
    }
};
```
* 从低到高，每轮结束后，在i到rk范围为以s[i]开头的最大不含有重复字符的子串。且必然由此得知i+1到rk也是不重复的，即rk随着i+1的递增也必然非降。
****

2. [力扣76]最小覆盖子串,给定s，t。求s内包含t所有字符的最小子串.(求数组a中包含b中全部元素的最短连续子集/求字符串a中包含字符串b中所有字符的最短子串)
+ 思路：求子串问题，考虑使用滑动窗口。由于可能有重复字符，重复字需要纳入计算。则可以通过计算窗口内的元素的个数，来判断是否满足要求，一旦满足要求，就可以尝试移动左指针，减小子串长度，直至不满足条件再继续移动右指针。

  ```c++
  class Solution {
      map<char, int> original, cnt;
      bool check()
      {
          for (auto &tempPair : original)
          {
              if (cnt.count(tempPair.first) == 0 || cnt[tempPair.first] < tempPair.second)
                  return false;
          }
          return true;
      }
  public:
      string minWindow(string s, string t) {
          for (const char& c : t)
          {
              ++original[c];
          }
          int left = 0, right = 0, minLength = INT_MAX, start = left;
          string temp;
          while(right < s.length())					//先移动右指针直到条件能满足
          {
              ++cnt[s[right]];
              while(check())							//条件满足了，就可以移动左指针，直到条件不满足，这时再移动右指针
              {
                  if (minLength > right - left + 1)
                  {
                      minLength = right - left + 1;
                      start = left;
                  }
                  --cnt[s[left++]];
              }
              ++right;
          }
          if (minLength < INT_MAX)
              return s.substr(start, minLength);		//根据记录的起点和长度，就可以得到最后的子串
          return temp;
      }
  };
  ```
****
3. 给定两个整型数组a,b。每次可以将a或者b中的一个数+1或者-1。问最少经过多少次这样的操作，可以使a中的最大值小于b中的最小值？
* 思路：首先我们可以对两数组的合并数组进行一个排序，同时利用一个结构数组array进行存储，这个结构包含了存储的数以及该数的个数，以及所属的数组是a还是b。然后利用双指针。寻找到a的最大值所在的位置pos1，以及b的最小值所在的位置。然后比较pos1与pos2所在位置的数的个数count。count少的先动，以pos1先动为例，要移动到下一个不小于array[pos2].num并且属于a的位置posTemp，移动的位数自然就是array[pos1].count * (pos1-posTemp)，同时要改变array[posTemp].count，应加上array[pos2].num。当然，如果没能找到下一个要移动到的结点，我们就直接移动到pos2-1处就行了。接着把pos2移动到posTemp，重复判断，移动，并记录移动次数即可。
****
4. 给定两个字符串S,T。求S中包含T所有字符的最短连续子字符串的长度。

+ 思路：使用滑动窗口，一左一右，确保left在right的左边。首先得使用一个O(1)读写的结构存储T的字符及其出现的次数。然后再对S进行遍历，对于S中的字符S[i]，如果S[i]已经在T中出现过，则将其减去，如果减去后余量>=0，说明是有效的字符数量统计，则对已经出现的字符数目count+1，反之则说明实际该字符数量已经超标了，不对count + 1；如果当前的count已经和T的字符数目相等，就对左边的指针进行操作，首先是记录当前状态下的size和区间，然后左移left直至count != T.length()；

```c++
class Solution
{
public:
	string minWindow(string S, string T) {
		vector<bool> hasCharacter(26, false);
		vector<int> characterNum(26, 0);
        //使用26个字符的hash进行记录
		for(char c : T)
		{
			hasCharacter[c - 'A'] = true;
			++characterNum[c - 'A'];
		}
		int left = 0, right = 0, minSize = INT_MAX, targetCount = T.length(), currentCount = 0, subStringLeftIndex = -1;
		int size = S.length();
		while(right < size)
		{
			if (hasCharacter[S[right] - 'A'])
			{
				--characterNum[S[right] - 'A'];
				if (characterNum[S[right] - 'A'] >= 0)//如果是有余量的，则应正确计入
					++currentCount;
			}
			while(currentCount == targetCount)
			{
				if (right - left + 1 < minSize)
				{
					minSize = right - left + 1;
					subStringLeftIndex = left;
				}
				if (hasCharacter[S[left] - 'A'])
				{
					++characterNum[S[left] - 'A'];
					if (characterNum[S[left] - 'A'] > 0)//如果是有余量的，则应正确计入count的数量，否则视为数量超标
						--currentCount;
				}
				++left;
			}
			++right;
		}
		return minSize < INT_MAX?S.substr(subStringLeftIndex, minSize):"";
	}
};
```

****

5. [Leetcode_524]

    给定一个字符串 s ，找出至多包含 k 个不同字符的最长子串 T的长度。
   > 示例 1:
   > 输入: s = “eceba”, k = 2
   > 输出: 3
   > 解释: 则 T 为 “ece”，所以长度为 3。
   > 示例 2:
   > 输入: s = “aa”, k = 1
   > 输出: 2
   > 解释: 则 T 为 “aa”，所以长度为 2。
+ 思路：由于需要找子串，使用滑动窗口正好合适。要得到子串里面包含了多少不同的字符，得使用一个数据结构来存储之，而且要随着指针的滑动，能快速删减元素，而且，考虑到可能有多个相同元素的情况，可以使用关联式容器，建议hash，即unordered_map。每当right移动到一个新元素，首先判断该元素的引入是否导致超过k个不同的字符，如果不会，就把right - left + 1记录下来；否则，开始移动left，使得为不同字符回到k时，再继续移动right，直到right没法再移动为止。

```c++
class Solution {
public:
	int lengthOfLongestSubstringKDistinct(string s, int k) {
        int length = s.length();
        unordered_map<char, int> charMap;
        int totalCount = 0, left = -1, right = 0, maxLength = right - left, temp;
        while(right < length)
        {
            if (charMap.find(s[right])!= charMap.end())
            {
                ++charMap[s[right]];
                temp = right - left;
                if (temp > maxLength)
                    maxLength = temp;
                ++right;
			}//如果right的字符已经存在，则说明是重复的
            else if (totalCount < k)
            {
                charMap[s[right]] = 1;
                ++totalCount;
                temp = right - left;
                if (temp > maxLength)
                    maxLength = temp;
                ++right;
            }//如果right的字符不存在，且总字符数还是少于k种，则可以加入
            else
            {
                while(left < right)
                {
                    ++left;
                    if (charMap.find(s[left]) != charMap.end())
                    {
                        --charMap[s[left]];
                        if (charMap[s[left]] == 0)
                        {
                            charMap.erase(s[left]);
                            --totalCount;
                            break;
                        }//如果当前left的字符已经存在，则减掉一个，如果减掉之后字符数量为0了，则清空它，同时停止
                    }
                }//如果right的字符不能加入，则移动left
            }
        }
        return maxLength;
    }
};
```

****

6. [力扣42]\[接雨水问题]给定一个高度数组，求能积累的雨水量

+ 思路：
  + <font color = #00c040>关键点：对任何位置的点，它能积累的水量和它两侧的最高的柱子的较小值有关。</font>
+ 解法1:[动态规划]用两个数组记录每个柱子的左右侧的最高的柱子高度，再遍历一遍，得到总和
  + 时间复杂度：O(n)
  + 空间复杂度：O(n)


```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int size = height.size();
        if (size <= 2)
            return 0;
        int * leftMaxHeights = new int[size];
        int * rightMaxHeights = new int[size];
        leftMaxHeights[0] = 0;
        rightMaxHeights[size - 1] = 0;
        int result = 0;
        for(int i = 1; i < size; ++i)
        {
            leftMaxHeights[i] = max(leftMaxHeights[i - 1], height[i - 1]);
            rightMaxHeights[size - 1 - i] = max(rightMaxHeights[size - i], height[size - i]);
        }
        for(int i = 0; i < size; ++i)
        {
            result += max(0, min(leftMaxHeights[i], rightMaxHeights[i]) - height[i]);
        }
        delete [] leftMaxHeights;
        delete [] rightMaxHeights;
        return result;
    }
};
```

+ 解法2：[双指针]使用left和right指针，用leftMax，rightMax记录当前区间（left, right）的左右侧的最大高度。我们在移动left和right的同时会更新leftMax，rightMax。如果leftMax<rightMax，则说明左边已经可以确定要用leftMax来计算了，这样计算之后移动left指针；同理右边也一样，对于相等的情况，两个应当都要计算并且移动，由于要避免left=right导致计算两次的情况，所以循环条件设置为left < right
  + 时间复杂度：O(n)
  + 空间复杂度：O(1)

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int size = height.size();
        if (size <= 2)
            return 0;
        int left = 0, right = size - 1;
        int leftHighest = height[left], rightHighest = height[right];
        int result = 0;
        while(left < right)
        {
            if (height[left] > leftHighest)
                leftHighest = height[left];
            if (height[right] > rightHighest)
                rightHighest = height[right];
            if (rightHighest >= leftHighest)
            {
                result += (leftHighest - height[left]);
                ++left;
            }
            else if (rightHighest <= leftHighest)
            {
                result += (rightHighest - height[right]);
                --right;
            }
        }
        return result;
    }
};
```

+ 解法3：[单调栈]单调栈无非四种，递增的或者递减的，非升的或非降的。这里应当使用递减或者非升的。以递减的为例，首先可以入栈第一个元素。对于之后的元素，如果它符合递减的准则，就继续入栈，直到出现第一个不符合条件的元素，这时可以说明它至少是top元素的一个右边界，包括它等于top的情况。而top元素的一个左边界就是top之前入栈的元素。通过这个关系可以一层一层地求出水面高度。

```c++
class Solution{
public:
    int trap(vector<int>& height) {
        int size = height.size();
        if (size <= 2)
            return 0;
        stack<int> singleStack;
        singleStack.push(0);
        int result = 0, i = 1;
        while(i < size)
        {
            //小于就入栈
            if (height[i] < height[singleStack.top()])
            	singleStack.push(i++);
            //否则出栈一个元素，再看栈是否为空，即有无左边界，为空说明无法计算，只能把当前的压栈；不为空，则取出并进行计算
            else
            {
                int topHeight = height[singleStack.top()];
                singleStack.pop();
                if (!singleStack.empty())
                {
                    int left = singleStack.top();
                    result += (min(height[left], height[i]) - topHeight) * (i - left - 1);//计算这一层的水量
                }
                else
                {
                    singleStack.push(i++);
                }
            }
        }
        return result;
    }
};
```

7. [力扣15]三个数的和。给一个nums，返回所有不重复的和为0的三个数组成的数组

+ 思路：基本思路是排序后枚举每个first，然后采用双指针second = first + 1和third = size - 1，只要三者和大于0，则左移third，反之右移second，直到second == third为止。这样的时间复杂度为O(n<sup>2</sup>)

  + 如何避免重复呢？其实只要保证first枚举的时候不重复，second枚举的时候也不重复就行。这样，由于和为0，自然可以保证third必然不重复

    ```c++
    for (first = start; first < end; ++first)
    {
        if (first > start && nums[first] == nums[first - 1])
            continue;
    }
    ```

  ```c++
  class Solution {
  public:
      vector<vector<int>> threeSum(vector<int>& nums) {
          int size = nums.size();
          if (size < 3)
              return {};									//个数小于3就返回
          sort(nums.begin(), nums.end());
          int first, second, third;
          vector<vector<int>> res;
          for (first = 0; first < size - 2; ++first)		
          {
              if (first > 0 && nums[first] == nums[first - 1])	//防止重复
                  continue;
              for (second = first + 1, third = size - 1; second < third; ++second)
              {													//用外层的for解决second右移的问题
                  if (second > first + 1 && nums[second] == nums[second - 1])//也是防止重复
                      continue;
                  while(second < third && nums[first] + nums[second] + nums[third] > 0)
                  {
                      --third;									//而用while循环解决左移third的问题
                  }
                  if (second != third && nums[first] + nums[second] + nums[third] == 0)
                      res.push_back({nums[first], nums[second], nums[third]});
              }
          }
          return res;
      }
  };
  ```

  

### [递归与深度优先搜索]

1. 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例 1：
>输入：n = 3
>输出：["((()))","(()())","(())()","()(())","()()()"]
>示例 2：
>输入：n = 1
>输出：["()"]
* 思路：有关生成类的问题以及列出所有可能值的问题一般就涉及搜索算法，而搜索最主要的就是利用树的结构进行深度优先或者广度优先搜索。如果自己不想维护树，就一般使用递归算法。递归函数的递归出口写开头。这里由于每次都复制数组，所以没必要回溯，否则也可以回溯
* 解法：
```C++
class Solution{
public:
    vector<string> generateParenthesis(int n) {
        vector<string> temp;
        //第一个必然是'('
        generateParenthesis(temp,n,"(",1,0);
        return temp;
    }
    void generateParenthesis(vector<string>&result,int n, string current, int leftNum, int rightNum)
    {
    	//左括号少于右括号数必然无效，直接出去。
        if (leftNum < rightNum || leftNum > n || rightNum > n)
        {
            return;
        }
        //左括号等于右括号数，且以及达到指定对数，则可以入列。同时也是递归出口
        if (leftNum == rightNum && leftNum == n)
        {
            result.push_back(current);
            return;
        }
        //否则要继续搜索。这里采用深度优先遍历。
        else{
            generateParenthesis(result,n,current + "(",leftNum+1,rightNum);
            generateParenthesis(result,n,current + ")",leftNum, rightNum+1);
        }
    }
};
```
2. [力扣200]岛屿数量。
给定一个由'0'，'1'表示的海域，其中0为水，1为陆地。求岛屿的数量。
+ 思路1：1是否是岛屿和其邻近块有关；因此可能需要考虑深度搜索和递归的问题；而只要它邻近的1是岛屿，则路径上访问到的所有的1都算成岛屿；这样，就需要记录已经访问过的结点。因此可以使用深度优先搜索或者广度优先搜索。时间复杂度是O(MN)
```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int rowSize =  grid.size();
        int columnSize = grid[0].size();
        int count = 0;
        vector<vector<bool>> gridTick(rowSize, vector<bool>(columnSize, false));
        function<bool(int, int)> checkIsland = [&] (int x, int y)->bool{
            if (x < 0 || y < 0 || x >= rowSize || y >= columnSize)
                return true;
            if (grid[x][y] == '0' || gridTick[x][y] == true)
                return true;
            gridTick[x][y] = true;
            return checkIsland(x - 1, y) && checkIsland(x + 1, y) && checkIsland(x, y + 1) && checkIsland(x, y - 1);
        };
        for (int i = 0; i < rowSize; ++i)
        {
            for (int j = 0; j < columnSize; ++j)
            {
                if (!gridTick[i][j] && grid[i][j] == '1' && checkIsland(i, j))
                    ++count;
            }
        }
        return count;
    }
};
```
****
### [单调栈]

#### 算法简述

+ 基本概念：单调栈分为单调递增栈和单调递减栈，以单调递增栈为例，遍历时，如果新元素比栈顶大，就入栈，反之，则一直出栈，直到栈为空或者栈顶元素小于新元素为止，再把新元素入栈。
+ 特性：
  + 元素是递增的
  + 可以在遍历过程中动态维护最值
  + <font color = "red">在添加新元素时，如果栈顶元素出栈，则说明新元素是栈顶元素之后第一个比其小的元素，出栈后新的栈顶元素是出栈元素之前的第一个比它小的元素。</font>
+ <font color = "red">实质：使用O(n)复杂度，在一重遍历内确定每个元素前后最近的更大/更小元素的位置。</font>
+ 单调栈模板

```c++
stack<int> st;
for(int i = 0; i < nums.size(); ++i)
{
	while(!st.empty() && st.top() > nums[i])
	{
		st.pop();
	}
	st.push(nums[i]);
}
```

#### 相关题目

1. 有n个人站队，所有的人全部向右看，个子高的可以看到个子低的发型，给出每个人的身高，问所有人能看到其他人发现总和是多少。
* 思路：单调栈分为单调递增栈和单调递减栈，通过使用单调栈我们可以访问到下一个比他大（小）的元素。也就是说在队列或数组中，我们需要通过比较前后元素的大小关系来解决问题时我们通常使用单调栈。在这个题目中，一个人是否能看到另一个人的发型，需要比较两人之间的高度，当然还有阻挡的问题。既然有关高度比较，可以使用单调栈，对于元素a以及栈顶元素stack.top()，只有a<b才入栈，否则出栈继续比较，直到a<stack.top() || stack.empty()，这样，完事之后，count+=(stack.size() - 1)；
```C++
	int totalVisiableNum(vector<int>& heights)
	{
		stack<int> lowerStack({heights[0]});
		int i = 1, size = heights.size();
		int count = 0;
		while(i < size)
		{
			if(heights[i] < lowerStack.top())
			{
				count += lowerStack.size();
				lowerStack.push(heights[i++]);
			}
			else
			{
				while(heights[i] >= lowerStack.top() || !lowerStack.empty())
				{
					lowerStack.pop();
				}
				count += lowerStack.size();
				lowerStack.push(heights[i++]);
			}
		}
		return count;
	}
```

****

2. [力扣剑指offer. 84]柱状图中最大矩形

   给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

   求在该柱状图中，能够勾勒出来的矩形的最大面积。

   ![](Pictures/2.jpg)

+ 思路：一个朴素的做法是使用二重循环+暴力枚举，不断计算以i，j为区间的最大矩形面积，并一直维护这个矩形面积的最大值。然而时间复杂度是O(n<sup>2</sup>)。

  仔细思考，i到j之间的矩形的面积取决于这之中最矮的矩形，那么另一个做法则是，从0到n-1枚举中间某个柱子，并认为这个柱子是区间最矮的，然后再找边界，这个边界内的所有柱子应该不低于middle柱子，求出其左右边界，再计算以该柱子为最矮柱子得到的面积。然而时间复杂度依然是O(n<sup>2</sup>)。

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        int ans = 0;
        for (int mid = 0; mid < n; ++mid) {
            // 枚举最矮高
            int height = heights[mid];
            int left = mid, right = mid;
            // 确定左右边界
            while (left - 1 >= 0 && heights[left - 1] >= height) {
                --left;
            }
            while (right + 1 < n && heights[right + 1] >= height) {
                ++right;
            }
            // 计算面积
            ans = max(ans, (right - left + 1) * height);
        }
        return ans;
    }
};
```

​		在采用上述做法时，每枚举一个中间柱子，在求边界时实际就等价于是求middle左侧右侧第一个小于middle的位置，而根据单调栈push和pop的本质，使用递增的单调栈，实际push操作说明新元素是栈顶元素后第一个大于栈顶元素的，实际pop操作后，新栈顶元素是出栈元素前第一个小于出栈元素的。那么，完全可以在遍历时一边维护单调栈，一边计算左右边界。

```c++
class Solution {
public:
    int largestRectangleArea(vector<int> &heights)
    {
        stack<int> s;
        int ans = 0;
        heights.push_back(0);//加个0强制到最后时计算所有以rihgt为原size-1的情况
        for (int i = 0; i < heights.size(); ++i)
        {
            while (!s.empty() && heights[s.top()] >= heights[i])
            {
                int h = heights[s.top()];
                s.pop();
                if (s.empty())
                    ans = max(ans, i * h);
                else
                    ans = max(ans, (i - s.top() - 1) * h);
            }
            s.push(i);
        }
        return ans;
    }
};
```



****

### [优先队列]

+ 特点：
  + 能在遍历时动态维护最值

1. 合并K个升序链表(力扣第23)

```C++
//优先队列：把所有的链表元素用小顶堆存储，然后再排出来即可
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() <= 0)
            return nullptr;
        ListNode * result = nullptr;
        ListNode * currentNode;
        priority_queue<int, vector<int>, greater<int>> tempQueue;
        for(auto iter = lists.begin(); iter != lists.end(); iter++)
        {
            ListNode* current = *iter;
            while(current)
            {
                tempQueue.push(current->val);
                current = current->next;
            }
        }
        if (!tempQueue.empty())
        {
            result = new ListNode(tempQueue.top());
            tempQueue.pop();
            currentNode = result;
        }
        while(!tempQueue.empty())
        {
            currentNode->next = new ListNode(tempQueue.top());
            tempQueue.pop();
            currentNode = currentNode->next;
        }
        return result;
    }
};
//分治法：用两个升序链表合并的方法，对其分治合并即可。
```
****
2. 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
+ 思路：使用两个栈，一个栈负责正常维护。另一个辅助栈则作为一个单调非降栈维护，对于这个辅助栈，每当要入栈新元素时，如果该辅助栈的端顶元素值大于它，则正常入栈它，否则就入栈一次端顶元素。出栈时，则同时出栈即可。
```c++
class MinStack {
    stack<int> thisstack;
    stack<int> minstack;
public:
    /** initialize your data structure here. */
    MinStack() {
        minstack.push(INT_MAX);
    }
    
    void push(int x) {
        thisstack.push(x);
        minstack.push(std::min(minstack.top(),x));
    }
    
    void pop() {
        thisstack.pop();
        minstack.pop();
    }
    
    int top() {
        return thisstack.top();
    }
    
    int min() {
        return minstack.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```

3. [力扣373]给定两个以 升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

+ 思路：这种最小的k个的问题，一般可以考虑向top-k问题靠拢，这样，就可以考虑使用优先队列。假如已经找到了i个最小的数对，且这i个的索引分别为{a1, b1}，{a2, b2}, {a3, b3}，...{ai, bi}。那么第i + 1个，必然是从{a1 + 1, b1}, {a1, b1 + 1}... {ai + 1, bi}， {ai, bi + 1}中选，也就是它们这些最小的元素中的某个下标往前挪一个位置这些候选里头选。

  然后我们知道第1个最小的必然是{0, 0}。

  这时一个简单的想法就是，从{0, 0}开始，选出一个最小值，就把{ai + 1, bi}和{ai, bi + 1}加入到priority_queue中，然而可能导致重复。例如选取{0,0}，插入了{1, 0}和{0, 1}，而只要{1, 1}在{1, 0}和{0, 1}之后被选，就会插入两遍{1, 1}

  这时，可以考虑先把nums1的所有元素和nums2的第0号元素的索引加入优先队列，这样，就不用再加入{ai + 1, bi}了，只要加入{ai, bi + 1}，因为{ai + 1, bi}已经提前加入了优先队列了

```c++
class Solution {
public:
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        auto Compare = [&nums1, &nums2] (const pair<int, int>& p1,const pair<int, int>& p2)
        {
            return nums1[p1.first] + nums2[p1.second] > nums1[p2.first] + nums2[p2.second];
        };
        vector<vector<int>> result;
        int size1 = nums1.size();
        int edgeSize = size1 <= k ? size1:k;
        int size2 = nums2.size();
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(Compare)> myQueue(Compare);
        /*priority_queue第二个模板参数传入使用的容器，第三个参数指定比较的类型；但要注意，与sort的不同的是，priority_queue是一个class，而sort仅仅是一个函数，如果要传仿函数，它需要传一个构造来的对象，不论是传入lambda函数还是仿函数亦或是普通的函数，它都通过调用一个辅助函数，利用函数的自动类型推断，构造并返回一个仿函数，这个仿函数构造时是使用move(function)来构造的，最终都是使用这个仿函数。
        而priority_queue的第三个模板参数则只能是一个类型，可以传入仿函数这个类型，然而如果要传入函数，就必须知道函数的类型，一个办法是使用上面的decltype，它可以从一个表达式或者一个变量中得到类型，这针对lambda表达式。另一个办法就是使用仿函数包装了，而且使用仿函数包装就可以不用传参了；使用类型推断则需要把函数传入才行；而对于一般的函数，你可以写出函数指针作为类型，参数再使用这个函数*/
        for (int i = 0; i < edgeSize; ++i)
        {
            myQueue.push({i,  0});
        }
        while(k-- && !myQueue.empty())
        {
            auto temp = myQueue.top();
            myQueue.pop();
            result.push_back({nums1[temp.first], nums2[temp.second]});
            if (temp.second < size2 - 1)
                myQueue.push({temp.first, temp.second + 1});
        }
        return result;
    }
};
```

+ 时间复杂度：O(klogk)，优先队列logk入队一个元素，首先入队了num1.size()个，然后再入队了k个
+ 空间复杂度：O(k)，因为它只保存了k个元素

4. [力扣239 滑动窗口内的最大值]

   给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。


+ 思路：可以使用优先队列，由于我们没办法在移动滑动窗口的时候把刚出窗口的元素给删除掉，而只能通过pop堆首元素进行删除，我们需要在优先队列里面记录当前top元素的index，如果index < left，那就要pop，直到index >= left。而使用优先队列存放pair的时候，比较会基于第一个元素first进行，如果相等则再基于第二个元素second进行，又有保证了元素各不相同，所以大顶堆可以直接放pair，这样也顺便存储了index。

  ```c++
  class Solution {
  public:
      vector<int> maxSlidingWindow(vector<int>& nums, int k) {
          int numsCount = nums.size();
          int resultSize = numsCount - k + 1;
          vector<int> result(resultSize);
          priority_queue<pair<int, int>> myQueue;
          for (int i = 0; i < k - 1; ++i)
          {
              myQueue.emplace(nums[i], i);
          }
          for (int leftBound = 0; leftBound < resultSize; ++leftBound)
          {
              myQueue.emplace(nums[leftBound + k - 1], leftBound + k - 1);
              while (leftBound != 0 && myQueue.top().second < leftBound)
                  myQueue.pop();
              result[leftBound] = myQueue.top().first;
          }
          return result;
      }
  };
  ```

  

### [哈希表]

1. ![](pictures/哈希表1.png)

+ 思路：在考虑复制时，最容易想到顺序复制，但是顺序复制会发现有些random没法复制，所以得换种办法；由于对每个结点的操作都是复制，可以采用递归算法。
  + 因为每个原结点都对应一个新复制的结点，所以具体来说，可以使用哈希表unordered_map<Node * ，Node *>，当一个结点要进行复制时，如果哈希表里没有，则说明要复制，并加入哈希表，同时这个结点指向的next和random也是如此。故可以进行递归。最后返回哈希表里的新结点值
  + 对于边界情况，则是结点为空的情况为空直接返回nullptr即可

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    unordered_map<Node*, Node*> nodeMap;
    Node* copyRandomList(Node* head) {
        if (head == nullptr)
            return nullptr;
        if (!nodeMap.count(head))
        {
            Node * newHead = new Node(head->val);
            nodeMap[head] = newHead;
            newHead->next = copyRandomList(head->next);
            newHead->random = copyRandomList(head->random);
        }
        return nodeMap[head];
    }
};
```

2. 设计LRU缓存结构，要求设置和获取的时间复杂度为O(1)

+ 思路：LRU涉及频繁插入删除，故使用list而不用vector，又要求在O(1)时间内完成操作，必须利用哈希表减少查找结点的时间。题目的vector分成两类，一种size = 2，vector[0] = 2，vector[1]表示key，将获取的value保存到vector里；一种size = 3，vector[0] = 1, vector[1] = key, vector[2] = val，表示设置LRU缓存内容。

```c++
class Solution {
private:
    unordered_map<int, list<pair<int, int>>::iterator> keyIterMap;//使用erase删除list，需要知道迭代器，故用unordered_map保存key到迭代器的映射
    list<pair<int, int>> LRUList;//需要注意，我们没法得到最后那个元素的迭代器，于是使用反向来放，最靠近begin的，即LRU的
    int size;
public:
    /**
     * lru design
     * @param operators int整型vector<vector<>> the ops
     * @param k int整型 the k
     * @return int整型vector
     */
    void set(int key, int value)
    {
        if (keyIterMap.count(key) > 0)
        {
            LRUList.erase(keyIterMap[key]);
        }
        if (LRUList.size() >= size)
        {
            keyIterMap.erase(LRUList.back().first);
            LRUList.pop_back();
        }
        LRUList.push_front(pair<int, int>(key, value));
        keyIterMap[key] = LRUList.begin();
    }
    vector<int> LRU(vector<vector<int> >& operators, int k) {
        size = k;
        vector<int> result;
        for (auto operation : operators)
        {
            if (operation[0] == 1)
            {
                set(operation[1], operation[2]);
            }
            else
            {
                result.push_back(get(operation[1]));
            }
        }
        return result;
    }
    int get(int key)
    {
        if (keyIterMap.count(key) > 0)
        {
            auto temp = *keyIterMap[key];				//这里一定别用auto& temp，因为一旦erase了，这个迭代器的内容就会被析构掉
            LRUList.erase(keyIterMap[key]);
            LRUList.push_front(temp);
            keyIterMap[key] = LRUList.begin();
            return temp.second;
        }
        return -1;
    }
};
```

3. [力扣128]最长连续序列

   给定一个不规则的数组，以O(n)时间复杂度求出最长连续序列的长度，不要求是子序列。

+ 思路：看到是O(n)而且还是非有序的数组，就得考虑哈希了。而使用哈希法，一般是作为一种优化手段，这样，可以先考虑暴力手段，再思考哈希该用在什么地方。一个普遍的暴力手段是：遍历每个元素，然后每个元素x都在数组里面搜索它的后一个x + 1，记录起来，一直到它不存在后继，这样就得到了以该元素为开始的最大的序列长度。如何使用哈希呢？首先哈希可以简化搜索过程，搜索的时候，每次都要O(n)进行搜索，使用哈希unordered_set可以降低到O(1)。还有一个问题，每个元素都要搜索直到不存在后继为止，这在本来就有序的情况下导致复杂度为O(n<sup>2</sup>)，原因在于，如果x本来已经有前驱了，既然x的都已经算过了，那这时再去求x+1的，也只会小于之前x的结果，所以一旦发现某个元素x有前驱x - 1，就不去计算它，这样可以保证复杂度为O(n)

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> numSet;
        int maxResult = 0;
        for (int x : nums)
        {
            numSet.insert(x);
        }
        for (int x : nums)
        {
            if (numSet.count(x - 1) != 0)
                continue;
            else
            {
                int current = x;
                int num = 1;
                while(numSet.count(current + 1))
                {
                    ++num;
                    current = current + 1;
                }
                maxResult = max(maxResult, num);
            }
        }
        return maxResult;
    }
};
```



****

### [二叉树]

1. 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

+ 思路：对于一棵二叉搜索树，它的中序遍历即可输出单调升序。那么我们可以利用它，首先是递归思路，我们进行深度优先遍历，当dfs(root->left)完成时，它会得到root的左边的结点pre，这时我们对pre进行判断，如果pre为空，说明当前root就是头结点，不需要处理连接，但是要把它记录成head；如果pre不为空，说明得到了root的左边结点，这时我们建立root和pre的连接，并将pre更新为root，再进行dfs(root->right)，就可以完成右边的遍历了。

 ```c++
 /*
 // Definition for a Node.
 class Node {
 public:
     int val;
     Node* left;
     Node* right;
 
     Node() {}
 
     Node(int _val) {
         val = _val;
         left = NULL;
         right = NULL;
     }
 
     Node(int _val, Node* _left, Node* _right) {
         val = _val;
         left = _left;
         right = _right;
     }
 };
 */
 class Solution {
 public:
     Node* treeToDoublyList(Node* root) {
         if(root == nullptr) return nullptr;
         dfs(root);
         head->left = pre;
         pre->right = head;
         return head;
     }
 private:
     Node *pre, *head;
     void dfs(Node* cur) {
         if(cur == nullptr) return;
         dfs(cur->left);
         if(pre != nullptr) pre->right = cur;
         else head = cur;
         cur->left = pre;
         pre = cur;
         dfs(cur->right);
     }
 };
 ```

2. [力扣98]判断一棵树是否是二叉搜索树并且是否是完全二叉树

```c++
/**
 * struct TreeNode {
 *    int val;
 *    struct TreeNode *left;
 *    struct TreeNode *right;
 * };
 */

class Solution {
public:
    bool inorder(TreeNode* root, int low, int high) {
        if (!root)
            return true;
          // 不满足中序遍历递增要求
        if (!(root->val >= low && root->val <= high))
            return false;
          // 分别递归左子树和右子树，同时更新low和high
        return inorder(root->left, low, root->val) && inorder(root->right, root->val, high);
    }
    vector<bool> judgeIt(TreeNode* root) {
        vector<bool> res(2); 
        if (!root) {
            res[0] = false; res[1] = false; 
            return res; 
        }
        // 中序遍历
        res[0] = inorder(root, INT_MIN, INT_MAX);
        // 定义队列层序遍历，只要遇到了空结点之后又遇到非空结点，就说明是非完全二叉树
        queue<TreeNode*> q; 
        bool flag = false; 
        res[1] = true; 
        q.push(root); 
        while (q.size()) {
            TreeNode* tmp = q.front(); 
            q.pop(); 
            // 遇到空结点 flag置为true
            if (!tmp) {
                flag = true; 
                continue; 
            } else {
                // 遇到非空结点
                if (flag) {
                    res[1] = false;
                    break;
                } else { // flag仍为false时，继续遍历
                    q.push(tmp->left); 
                    q.push(tmp->right); 
                }
            }
        }
        return res; 
    }
};
```

3. 根据一棵树的前序遍历和中序遍历结果得到一棵树

+ 思路1——递归
  + 既然是递归，必然有一个统一的递归形式。已知前序，中序都是vector，那么一个合适的形式就是传入vector，指定其左右边界。递归的结果自然是返回构造的子树的根节点。再说回解题思路，前序遍历的结果是[根]\[左子树]\[右子树]，中序则是[左子树]\[根]\[右子树]，关键点则是左子树的长度在两个遍历方式中是相同的，如此，则通过前序的first找到中序的middle，得到左右子树长度，然后分割为左子树和右子树的构造；在中序中找first，可以使用哈希表，将中序的元素作key，下标作value，加速查找。
  + 时间复杂度:要构造每个结点，而且每个结点在O(1)时间内得到构造，故为O(n)
  + 空间复杂度：O(n)，主要是建立了map

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    unordered_map<int, int> indexMap;
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int size = inorder.size();
        for (int i = 0; i < size; ++i)
        {
            indexMap[inorder[i]] = i;			//建立map
        }
        return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
    }
    TreeNode* buildTree(vector<int>& preorder, int leftBound, int rightBound, vector<int>& inorder, int leftEdge, int rightEdge)
    {
        if (leftBound > rightBound || leftEdge > rightEdge)
            return nullptr;
        int index = indexMap[preorder[leftBound]];
        TreeNode* currentRoot = new TreeNode(preorder[leftBound]);
        currentRoot->left = buildTree(preorder,leftBound + 1, leftBound + index - leftEdge, inorder, leftEdge, index - 1);
        currentRoot->right = buildTree(preorder, leftBound + index - leftEdge + 1, rightBound, inorder, index + 1, rightEdge);
        return currentRoot;
    }
};
```

4. [力扣236. 找到两节点的最近公共祖先]

   给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

   百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

+ 思路1：使用深度优先搜索。从叶子结点自底向上一个个判断，就能取得最近公共祖先了。因为最近公共祖先的特点只有一个结点能满足，即((leftSon && rightSon) || (root->val == p->val || root->val == q->val) && (lson || rson))，即该结点的左右子树分别有其中一个结点，或者是它本身就等于其中一个结点，同时以它为根的子树里面有另一个结点。而dfs返回值就是表示以root为根的子树里面是否有其中一个结点，即：左右子树里面存在其中一个结点，或者是根本身就等于其中一个结点

  ```c++
  class Solution {
  public:
      class Solution {
  public:
      TreeNode* ans;
      bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
          if (root == nullptr) return false;
          bool lson = dfs(root->left, p, q);
          bool rson = dfs(root->right, p, q);
          if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) {
              ans = root;
          } 
          return lson || rson || root->val == p->val || root->val == q->val;
      }
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          dfs(root, p, q);
          return ans;
      }
  };
  ```

+ 思路2：二叉树问题一切还是回归到三种遍历，递归，深度与广度搜索的套路上来。如果使用中序遍历，要是发现p，q同时在当前结点current的左侧，则说明都在current->left子树上，只有发现current == p || current == q或者p，q分别在current的左右子树上了，才说明current就是最近公共祖先。

+ 如果使用中序遍历记录结点的值到一个数组上，我们还需要知道p，q相对于current的下标位置，所以可以使用哈希表记录val到下标index的索引，便于查找。

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   * };
   */
  class Solution {
  public:
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          vector<int> values;
          unordered_map<int, int> myMap;
          inorderTranversal(root, values, myMap);	//中序遍历
          TreeNode* current = root;
          int currentIndex = myMap[current->val];
          int pPos = myMap[p->val];
          int qPos = myMap[q->val];
          while(qPos != currentIndex && pPos != currentIndex)
          {
              if (qPos < currentIndex && pPos < currentIndex)
              {
                  current = current->left;
                  currentIndex = myMap[current->val];
              }
              else if (qPos > currentIndex && pPos > currentIndex)
              {
                  current = current->right;
                  currentIndex = myMap[current->val];
              }
              else break;
          }
          return current;
      }
  
      void inorderTranversal(TreeNode* root, vector<int>& values, unordered_map<int, int>& myMap)
      {
          if (root == nullptr)
              return;
          inorderTranversal(root->left, values, myMap);
          values.push_back(root->val);
          myMap[root->val] = values.size() - 1;
          inorderTranversal(root->right, values, myMap);
      }
  };
  ```


5. [力扣103]二叉树的锯齿状遍历

+ 思路：基本就是先层序遍历，将结果存到一个vector内，然后看是奇数层还是偶数层(从1开始)，是偶数层就调用reverse(vector.begin(), vector.end())，再将结果存到res里头完事。

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      queue<TreeNode *> tempQueue;
      vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
          if (root == nullptr)
          {
              return {};
          }
          vector<vector<int>> res;
          tempQueue.push(root);
          int floorTick = 1;
          while(!tempQueue.empty())
          {
              int size =  tempQueue.size();
              vector<int> resultInThisFloor;
              while(size--)
              {
                  auto node = tempQueue.front();
                  resultInThisFloor.push_back(node->val);
                  if (node->left)
                      tempQueue.push(node->left);
                  if (node->right)
                      tempQueue.push(node->right);
                  tempQueue.pop();
              }
              if (floorTick % 2 == 0)
                  reverse(resultInThisFloor.begin(), resultInThisFloor.end());
              ++floorTick;
              res.push_back(resultInThisFloor);
          }
          return res;
      }
  };
  ```

6. [力扣199]二叉树的右视图。给定一棵树的根，从树的右边看，将能看到的结点记录成数组。

+ 思路：首先想到深度优先搜索，那么就要优先搜索右边的结点，如果发现右边的没了，就要去搜索左边的，同时，还应当记录当前已经能看到的层数，这样在搜索左边的子树的时候就不至于无法判断是否是被遮挡，只要层数小于等于已经看到了的层数，就说明左边的被遮挡了。

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
      vector<int> res;
      int currentDepth;
  public:
      void dfs(TreeNode* root, int depth)
      {
          if (depth > currentDepth)
          {
              res.push_back(root->val);
              currentDepth = depth;
          }
          if (root->right)
              dfs(root->right, depth + 1);
          if (root->left)
              dfs(root->left, depth + 1);
      }
      vector<int> rightSideView(TreeNode* root) {
          if (root == nullptr)
              return {};
          currentDepth = 0;
          dfs(root, 1);
          return res;
      }
  };
  ```

  

### [对顶堆]
1. [剑指offer41] 维护数据流中的中位数
+ 思路：没啥好说的，直接对顶堆即可。注意好对顶堆的维护方法
```c++
class MedianFinder {
public:
    /** initialize your data structure here. */
    //对顶堆
    priority_queue<int> bigTopHeap;
    priority_queue<int, vector<int>, greater<int>> smallTopHeap;  
    double getMedian(vector<int>& nums)
    {
        for (int x : nums)
        {
            addNum(x);
        }
        return findMedian();
	}
    void addNum(int num) {
        if (bigTopHeap.size() == 0 || num < bigTopHeap.top())
        {
            bigTopHeap.push(num);
        }
        else
            smallTopHeap.push(num);
        while (bigTopHeap.size() > smallTopHeap.size() + 1) 
        {
            smallTopHeap.push(bigTopHeap.top());
            bigTopHeap.pop();
        }
        while (smallTopHeap.size() > bigTopHeap.size() + 1) 
        {
            bigTopHeap.push(smallTopHeap.top());
            smallTopHeap.pop();
        }
        //如果不是求中位数，则改这里就行
    }
    
    double findMedian() {
        if ((smallTopHeap.size() + bigTopHeap.size())%2)
        {
            if (smallTopHeap.size() > bigTopHeap.size())
                return smallTopHeap.top();
            return bigTopHeap.top();
        }
        return (bigTopHeap.top() + smallTopHeap.top())/2.0;
    }
};
```

****

### [贪心算法]

#### 算法简述

+ 贪心算法主要在于从局部最优得到全局最优。基本问题如：区间问题，分配问题。贪心算法题也是需要最优子结构的，且往往快于动态规划。

+ 问题的关键在于如何度量最优。如何确定贪心策略。

  + 一般的问题都会涉及一个给定集合S。

    那么贪心策略可以是：

    + 在考虑子集合A时，在A的解达到最优时,能够使得S-A尽可能最优的策略。求达到最大，最多的时候可能要用。如：Leetcode_605
    + 在考虑子集合A时，能使得A达到最优的策略。每次扩大集合A时，都使得当前A达到最优。这颇有动规的感觉。如：Leetcode_452

+ 一些常用的思考方式：

  + 从局部出发，寻找一个较小集合，即基本情况下该如何求解。并迭代扩大集合，看如何演变。如:Leetcode_406

+ 一些常涉及的操作：
  + 按某个规律对集合排序
  + 记录区间，并排序

#### 相关题目

1. [LeetCode_605]假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

   给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。

+ 思路：先将flowerbed分成两个部分，一前一后，在前面可种植数已确定的情况下，前面的最后一个可种植位置越在前面，后面的可种植数量就更多。所以，这里的贪心策略就是：每次都使得该种植位置尽量靠左。让余下的部分有更多的可能。

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int size = flowerbed.size();
        if (size < 2 * n - 1)
            return false;
        int count = 0;
        for (int i = 0; i < size;)
        {
            if (flowerbed[i] == 0)
            {
                if (i == size - 1 || flowerbed[i + 1] == 0)
                {
                    count++;
                    i += 2;
                }
                else
                {
                    i++;
                }
            }
            else
                i+=2;
        }
        return count >= n;
    }
};
```

****

2.[LeetCode_452]假设有一堆气球，每个气球有左右边界，可能存在重叠，现在可以使用飞针刺穿之，对于重叠的气球，可以完全穿透，请问最少使用多少个针头可以全部刺穿？

+ 思路：首先判断问题类型，很明显，这里区间问题的气息浓厚，可能需要进行排序，不妨利用左边界升序排序好了。得到这个结果后，进行分析：我们知道，对气球i，引爆它最后的机会在它的右边界。那么如果按照区间顺序得到的第i +1个气球的右边界在气球i的左边，则我们可以同时击穿这两个气球，同时击穿的最后机会在i+1的右边界；如果i+1气球的右边界在i气球的右边，但i+1气球的左边界在其左边，则我们依然可同时击穿，击穿的最后机会在i的右边界；但如果i+1气球完全在i气球的右边，则无法同时击穿，只能多用一个刺针。

  这里的贪心策略在于：对于每个气球，我都找能击穿它的最右边的位置，看看在这之前能不能尽量击穿更多的气球。

```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), [](const vector<int>& a,const vector<int>& b){return a[0] < b[0];});
        int pos = points[0][1];//记录第1个气球的右边界
        int count = 1;
        for(const vector<int>& u : points)
        {
            if (u[1] < pos)
            {
                pos = u[1];
            }//如果下一个气球的右边界在其左边，我就移动到击穿这个气球的最后位置
            else if (u[0] > pos)
            {
                pos = u[1];
                count++;
            }//如果下一个气球的右边界在其右，且左边界也在其右，我就得多用一个针头了。前面这些击穿了，就移动到该气球的右边界，进行下一个循环。
        }
        return count;
    }
};
```

****

3. [Leetcode_406]假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
   请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

+ 思路：典型的从局部到整体的思路。首先看需不需要排序。也就是说看处理顺序的不同是否有很大影响，这要看处理集合迭代时的影响。设之前加入新加的元素为(x, y)，迭代集合时加入新加的元素为(a, b)

  + 如果a < x，那么原来处理的顺序都是不受影响的，因为它最矮，不改变之前处理的相对顺序，只要给(a, b)找空即可。
  + 如果a > x，那么只要b大于0，它就暂时找不到合适的位置。这说明处理顺序对其有影响。
  + 如果a == x && b > y，将新元素插入时，可以发现它也不改变原来结果的相对位置，它只要放在(x, y)的后面即可。
  + 如果a == x && b < y，将新元素插入时，它会放在(a, b)的前面，这意味着(a, b)可能会在不合适的位置上。

  既然发现不同的顺序会有不同的结果，那么就进行排序。高的在前，同高则ki小的在前。

  在排完序后，对一个新增的进行处理，因为里面已经排好的都是高度大于等于当前新增的元素的，所以只要根据ki就决定它在哪了。

  这里看不出啥贪心策略。只有局部到整体 + 看出顺序对处理决策的影响 + 排序后的解决办法

```c++
//用堆进行处理，注意堆的比较，greater表示小顶堆，因为堆顶放在最后一个元素，自定义得用伪函数
class Solution {
public:
    struct PeopleCompare
    {
        bool operator()(const pair<int,int>& pair1, const pair<int,int>& pair2)
        {
            return (pair1.first < pair2.first) || (pair1.first == pair2.first && pair1.second > pair2.second);
        }
    };//这是一个伪函数
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        vector<vector<int>> result;
        priority_queue<pair<int, int>, vector<pair<int,int>>, PeopleCompare> smallTopHeap;
        for(auto peopleInfo : people)
        {
            smallTopHeap.push(make_pair(peopleInfo[0],peopleInfo[1]));
        }
        while(!smallTopHeap.empty())
        {
            pair<int, int> topInfo = smallTopHeap.top();
            smallTopHeap.pop();
            Insert(result, topInfo);
        }
        return result;
    }

    void Insert(vector<vector<int>>& result,pair<int, int> topInfo)
    {
        bool hasInserted = false;
        int size = result.size();
        if (size == 0)
        {
            result.push_back({topInfo.first, topInfo.second});
            return;
        }
        auto iter = result.begin();
        int currentBiggerNum = 0;
        while(iter != result.end())
        {
            if (currentBiggerNum >= topInfo.second)
            {
                result.insert(iter,{topInfo.first, topInfo.second});
                return;
            }
            else
                currentBiggerNum++;
            iter++;
        }
        result.push_back({topInfo.first,topInfo.second});
    }
};

//改成sort排序，也差不多，复习下lambda
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        vector<vector<int>> result;
        sort(people.begin(),people.end(),[](vector<int>&people1, vector<int>&people2){return people1[0] > people2[0] || (people1[0] == people2[0] && people1[1] < people2[1]);});
        for(auto peopleInfo : people)
        {
            Insert(result,peopleInfo);
        }
        return result;
    }

    void Insert(vector<vector<int>>& result,vector<int>& topInfo)
    {
        int size = result.size();
        if (size == 0)
        {
            result.push_back({topInfo[0], topInfo[1]});
            return;
        }
        auto iter = result.begin();
        int currentBiggerNum = 0;
        while(iter != result.end())
        {
            if (currentBiggerNum >= topInfo[1])
            {
                result.insert(iter,{topInfo[0], topInfo[1]});
                return;
            }
            else
                currentBiggerNum++;
            iter++;
        }
        result.push_back({topInfo[0], topInfo[1]});
    }
};
```

****

4. [Leetcode_665]给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。

   我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。

+ 思路：首先这个数列没法动，也就没法排序。对于nums[i] > nums[i + 1]的情况，需要看是把nums[i]变成nums[i + 1]合适还是把nums[i + 1]变成nums[i]合适。如果nums[i - 1]也比nums[i + 1]大或者等于，则只能变nums[i + 1]，否则可以变nums[i]。记录变化的次数，只要超过一次就说明不成立。

  ```c++
  class Solution {
  public:
      bool checkPossibility(vector<int>& nums) {
          int size = nums.size();
          if (size == 1)
              return true;
          int i = 0;
          int count = 0;
          while(i < nums.size() - 1)
          {
              if (nums[i] > nums[i + 1])
              {
                  if (i == 0 || nums[i + 1] >= nums[i - 1])
                  {
                      nums[i] = nums[i + 1];
                  }
                  else
                  {
                      nums[i + 1] = nums[i];
                  }
                  count++;
                  if (count > 1)
                      return false;
              }
              i++;
          }
          return count <= 1;
      }
  };
  ```


5. [力扣135]分糖果。n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

   你需要按照以下要求，给这些孩子分发糖果：

   每个孩子至少分配到 1 个糖果。
   相邻两个孩子评分更高的孩子会获得更多的糖果。
   请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目

+ 思路：可以分开设置为两个规则。

  + 左规则：如果分数小于等于左边的，就分1个糖，反之分left[n] + 1个糖。
  + 右规则：如果分数小于等于右边的，就分1个糖，反之分right[n] + 1个糖。

  根据左规则得到结果就是满足左规则所需的最小糖果数量。先遍历数组，得到满足左规则的结果，然后再遍历数组，看每个元素满足右规则时的糖果数right，每个元素都取其中的较大值

  ```c++
  class Solution {
  public:
      int candy(vector<int>& ratings) {
          int n = ratings.size();
          vector<int> left(n);
          for (int i = 0; i < n; i++) {
              if (i > 0 && ratings[i] > ratings[i - 1]) {
                  left[i] = left[i - 1] + 1;
              } else {
                  left[i] = 1;
              }
          }
          int right = 0, ret = 0;
          for (int i = n - 1; i >= 0; i--) {
              if (i < n - 1 && ratings[i] > ratings[i + 1]) {
                  right++;
              } else {
                  right = 1;
              }
              ret += max(left[i], right);
          }
          return ret;
      }
  };
  ```

  + 至于为什么这么考虑是正确的。
    + 在左规则完成的基础上，已经得到了第i个孩子满足左规则的最小糖果数量，那么它如果要在此基础上满足其它规则，即取交集，糖果数量就必然大于等于这个最小糖果数量。
    + 当从右往左进行右规则的确定时，我们依据了左规则来对结果进行修正，也即在左规则满足的基础上确定满足右规则的糖果的数量，所以糖果数从右往左，总是大于等于之前存放的最小糖果数量。

### [二分查找]

#### 算法简述

+ 二分：每次查找时将区间分成两部分，并进行剪枝，只取一部分继续查找。
+ 时间复杂度：
  + 最好O(1)
  + 最坏O(logn)
  + 平均O(logn)

+ 空间复杂度：
  + 迭代版本为O(1)
  + 递归(无尾调用消除，即函数最后是调用函数)版本是O(logn)


```c++
int binary_search(int start, int end, int key) {
  int ret = -1;  // 未搜索到数据返回-1下标
  int mid;
  while (start <= end) {
    mid = start + ((end - start) >> 1);  // 直接平均可能会溢出，所以用这个算法，值大于0时右移一般更快
    if (arr[mid] < key)
      start = mid + 1;
    else if (arr[mid] > key)
      end = mid - 1;
    else {  // 最后检测相等是因为多数搜索情况不是大于就是小于
      ret = mid;
      break;
    }
  }
  return ret;  // 单一出口
}
```

#### 最大值最小化

+ 所谓有序，可以是广义的概念，一个数组的一侧全满足某条件，而另一侧都不满足，也算有序。
+ 求解最大值最小化，可以使用<font color = "red">二分+剪枝</font>，并且对于这种问题，它一般都是NP完全问题。
  + 条件是答案在一个固定区间内
  + 查找一个答案比较难，但是能容易地判断值是否符合条件。
  + 可行解对于区间满足一定的单调性。即，若X合法，则X+1或者X-1也合法。

#### C++STL中的二分

+ std::lower_bound是查找首个不小于给定值的元素
+ std::upper_bound是查找首个大于给定值的元素
+ 见相关题目的第1题

#### 算法模板

****

##### 模板一

+ 特点：
  + 适用于最一般的查找，元素出现就返回，也是最普通的写法。
  + 使用≤进行循环判断
  + 判断middle的等于的情况

```c++
int search(vector<int>& nums, int target) {
    int size = nums.size();
    int left = 0, right= size - 1;
    while(left <= right)
    {
        int middle = left + ((right - left)>>1);
        if (nums[middle] == target)
        {
            return middle;
        }
        if (nums[middle] < target)
            left = middle + 1;
        else
            right = middle - 1;
    }
    return -1;
}
```

##### 模板二

```c++
int search(vector<int>& nums, int target) {
    int size = nums.size();
    int left = 0, right= size - 1;
    while(left < right)
    {
        int middle = left + ((right - left)>>1);//切记要打括号
        if (nums[middle] < target)
        {
            left = middle + 1;
        }
        else right = middle;
    }
    return nums[left]==target?left:-1;
}//用于查找第一次出现的位置
```

##### 模板三

```c++
int search(vector<int>& nums, int target) {
    int size = nums.size();
    int left = 0, right= size - 1;
    while(left < right)
    {
        int middle = (left + right + 1)>>1;//这个写法使得middle靠近right而不是left，相当于和上面那个完全相反
        if (nums[middle] > target)
        {
            right = middle - 1;
        }
        else left = middle;
    }
    return nums[left]==target?left:-1;
}//用于查找最后一次出现的位置
```



#### C语言的二分与排序

+ bserach()二分查找
+ qsort()快速排序
  + void(void *ptr, size_t count, size_t size, * comp);
    + ptr: 表示按照升序给定的数组
    + count: 数组元素个数
    + size: 每个元素大小
    + comp:     int cmp(const void *a, const void\* b)

#### 相关题目

1. 给定一个**增序**的整数数组和一个值，查找该值第一次和最后一次出现的位置。

+ 思路：这实际相当于实现lower_bound和upper_bound函数

```c++
class Solution{
public:
    vector<int> serachRange(vector<int>& nums, int target)
    {
        if (nums.empty()) return vector<int>{-1,-1};
        int lower = Lower_Bound(nums, target);
        int upper = Lower_Bound(nums, target);
        if (lower == nums.size() || nums[lower] != target)
            return vector<int>{-1,-1};
        return vector<int>{lower, upper};
    }
    int Lower_Bound(vector<int>& nums, int target)
    {
        int left = 0, right = nums.size(),middle;
        while(left < right)
        {
            middle = left + ((right - left) >> 1);
            if (nums[middle] < target)
            {
                left = middle + 1;
            }
            else
            {
                right = middle;//注意不是middle - 1，因为对应<=的情况
            }
		}
        return left;
	}
    int upper_bound(vector<int> &nums, int target) {
	int l = 0, r = nums.size(), mid;
	while (l < r) {
	mid = l + ((r - l)>>1);
	if (nums[mid] > target) {
		r = mid;
	} 
    else {
		l = mid + 1;
	}
}
```
****

2. 给定一个原本增序数组的旋转数组nums，给定一个值target，查找target是否在nums中

+ 思路：对于一个旋转数组，包括其子数组在内的所有数组，划分成两个部分，如果一遍是非严格递增的，那另一边肯定是严格递增，就可以借此去判断什么时候target会到严格递增的那边，那么对立事件就是target在左边了，当然，也可以分别考虑两种情况，统一得到right向左规约的条件。<font color = "red">而事实上，二分碰到非严格的数组时，往往只需要对条件进行适当的修改，毕竟二分就是确定答案在哪个区间的。</font>对于此题，可以分情况讨论，由于是严格增序的，那么
  + nums[middle] > nums[left]
    + 这时说明left到middle是一个严格递增的。如果target正好在left，middle之内，必然是right = middle - 1，其余的肯定都是left = middle + 1

  + nums[middle] < nums[left]
    + 这时候左边是非严格递增的。右边则是严格递增的，可以考虑啥时候left往右，然后取对立事件，当然也可直接看啥时候right往左
    + right往左的情况，即target  >= nums[left]，或者是target < nums[middle]的时候


```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left < right)
        {
            int middle = left + ((right - left)>>1);
            if (nums[middle] == target)
                return middle;
            if ((nums[middle] >= nums[left] && target < nums[middle] && target >= nums[left]) 
            || (nums[middle] < nums[left] && (target >= nums[left] || target < nums[middle])))
            {
                right = middle - 1;
            }
            else
            {
                left = middle + 1;
            }
        }
        return nums[left] == target?left:-1;
    }
};
```

****

3. [极小化极大]\[力扣875]N堆香蕉，第i堆有piles[i]个，要在H小时内吃完，假设吃香蕉速度为K/h，每小时可以随便选一堆吃，如果数量少于k个，则这小时吃光它，不再吃其它的香蕉，否则就吃k个。求能吃完所有香蕉的最小k。

+ 思路：要求出所有可行解，很麻烦，但对于每个值，都可以验证，而且如果某个k不足，则至少答案在k之上，如果k足够了，则k以上的都行。这样，可以转换成一个二分查找。

```c++
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int low = 1, high = INT_MAX;
        int middle = low + ((high - low)>>1);
        // 使用INT_MAX，最多30次回到最小值1
        while(low < high)
        {
            if (!CanEatOut(piles, middle, h))
                low = middle + 1;
            else
                high = middle;
            middle = low + ((high - low)>>1);
            //一个二分
        }
        return middle;
    }
    bool CanEatOut(vector<int>& piles, int perEatNum, int time)
    {
        int size = piles.size();
        int result = 0, i = 0;
        while(i < size)
        {
            int temp = piles[i];
            result += temp/perEatNum;
            if (temp%perEatNum)
                result++;
            if (result > time)
                return false;
            ++i;
        }
        return true;
    }
};
```

****

4. [极小化极大]\[力扣2064]

   给你一个整数 `n` ，表示有 `n` 间零售商店。总共有 `m` 种产品，每种产品的数目用一个下标从 **0** 开始的整数数组 `quantities` 表示，其中 `quantities[i]` 表示第 `i` 种商品的数目。

   你需要将 **所有商品** 分配到零售商店，并遵守这些规则：

   - 一间商店 **至多** 只能有 **一种商品** ，但一间商店拥有的商品数目可以为 **任意** 件。
   - 分配后，每间商店都会被分配一定数目的商品（可能为 `0` 件）。用 `x` 表示所有商店中分配商品数目的最大值，你希望 `x` 越小越好。也就是说，你想 **最小化** 分配给任意商店商品数目的 **最大值** 。

   请你返回最小的可能的 `x` 。

+ 思路：和上题差不多，略。

```c++
class Solution {
public:
    int minimizedMaximum(int n, vector<int>& quantities) {
        int low = 1, high = INT_MAX;
        int middle = low + ((high - low)>>1);
        while(low < high)
        {
            if (CanSolve(quantities, n, middle))
            {
                high = middle;
            }
            else
            {
                low = middle + 1;
            }
            middle = low + ((high - low)>>1);
        }
        return middle;
    }
    bool CanSolve(vector<int>& quantities, int n, int maxNum)
    {
        int result = 0, i = 0, size = quantities.size();
        while(i < size)
        {
            int temp = quantities[i];
            result += temp/maxNum;
            if (temp%maxNum)
                ++result;
            if (result > n)
                return false;
            ++i;
        }
        return true;
    }
};
```

++++

5. [力扣6010]完成旅途的最少时间。给定一个vector\<int> time，存放每个车子完成一次旅途所需要的天数，每个车子完成一趟后可以立刻进行下一趟，计算完成指定旅途数量totalTrips所需要的最少天数。

+ 思路：对于每个天数，我们都可以进行验证，同时我们可以知道它的上下界，下界为time[0]，上界为total Trips * time[0],这样就可以使用二分了
+ 二分一定注意left + ((right - left)>>1);要写两个括号，因为优先级的关系

```c++
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        sort(time.begin(), time.end());
        unsigned long long left = time[0], right = totalTrips * left;
        while(left < right)
        {
            long long middle = left + ((right - left)>>1);
            if (canFitIt(time, middle, totalTrips))
                right = middle;
            else
            {
                left = middle + 1;
            }
        }
        return left;
    }
    bool canFitIt(vector<int>& time, long long days, int totalTrips)
    {
        unsigned long long count = 0;
        for (int i = 0; i < time.size(); ++i)
        {
            if (time[i] > days)
                break;
            count += days / time[i];
        }
        return count >= totalTrips;
    }
};
```



### [排序算法]

#### 算法描述

+ 快速排序
+ 时间复杂度：
  + 平均：O(nlogn)  
  + 最好O(nlogn) 序列总是均分成两个子序列
  + 最坏:O(n<sup>2</sup>)  每次都搜到另一头，也就是数组正好反序
+ 空间复杂度:O(logn)
+ 稳定性：不稳定

```c++
class Solution
{
public:
	void quick_sort(vector<int>& nums, int left, int right)
	{
		if (left + 1>= right)
			return;
		int leftIndex = left, rightIndex = right - 1, value = nums[leftIndex];
		while(leftIndex < rightIndex)
		{
			while(leftIndex < rightIndex && nums[rightIndex] >= value)
			{
				--rightIndex;
			}
			nums[leftIndex] = nums[rightIndex];
			while(leftIndex < rightIndex && nums[leftIndex] <= value)
			{
				++leftIndex;
			}
			nums[rightIndex] = nums[leftIndex];
		}
		nums[leftIndex] = value;
		quick_sort(nums, left, leftIndex);
		quick_sort(nums, leftIndex + 1, right);
	}
};
//快排的参数left，right表示考虑[left, right)下标内的元素
```

+ 快排的优化策略
  + 枢纽元：枢纽元是指当前要排的数。

  + 选取策略：

    + 最普通的选取是选择第一个或者最后一个元素作为枢纽元
    + 随机选取：从left到right中随机取index，将nums\[index]作为当前枢纽元
    + <font color = "red">三数取中法</font>：将nums\[left]、nums\[right]、nums[(left + right)/2]的中位数作为选取的值。实际减少了14%的比较

  + 优化策略：

    + <font color = "red">当数组大小较小时，转用插入排序。</font>一般可以取n = 5到12，改用插入排序

    + <font color = "red">聚集元素</font>

      例子：1 4 6 7 <font color ="red">6</font> 6 7 6 8 6

      三数取中，为6，将其与1交换

      <font color = "red">6</font> 4 6 7 1 6 7 6 8 6

       ↑                             ↑

      

#### 相关题目

1. [TOP-K问题，力扣215]求数组中第k大的数

```c++
// 方法1 O(nlogn)与O(n^2)，取决于排序算法的选取 排序后第k-1个元素
// 方法2 O(n^2) 
```

****

2. [力扣2199、剑指offer51. 数组中的逆序对(归并排序、前缀和)]

   在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

+ 思路：求逆序对，我们很容易想到基于比较的排序。于是第一种方法就是采用归并排序，归并排序是一种典型的分治算法，它会首先通过递归将数组分割成只有2个元素大小的单元，并进行比较排序，然后再变成两个排好序的2元素大小数组，排序成有序列表。只要我们在数组排序成从小到大的过程中进行记录即可。
+ 复杂度分析：时间复杂度:O(nlogn),空间复杂度:O(n)

```c++
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        int size = nums.size();
        vector<int> temp(size, 0);
        return mergeSort(nums, temp, 0, size - 1);	//归并排序需要一个辅助数组，假设采用闭区间
    }
private:
    int mergeSort(vector<int>&nums,vector<int>& temp, int left, int right)
    {
        if (left >= right)
            return 0;								//大小为1则无需排序，是递归出口
        int middle = left + ((right - left)>>1);	//取中值切分
        int totalResult = mergeSort(nums, temp, left, middle) + mergeSort(nums, temp, middle + 1, right);
        											//进行递归
        int leftPtr = left, rightPtr = middle + 1, index = left;
        while(leftPtr <= middle && rightPtr <= right)
        {
            if (nums[leftPtr] <= nums[rightPtr])
            {
                temp[index++] = nums[leftPtr];
                totalResult += (rightPtr - middle - 1);
                leftPtr++;							//对前面归并完成的两部分之间的进行统计
                								//左边的小，要插入数组，说明它大于已经在数组内的来自右边部分的数
            }
            else
            {
                temp[index++] = nums[rightPtr];
                rightPtr++;
            }
        }
        while(leftPtr <= middle)
        {
            temp[index++] = nums[leftPtr++];
            totalResult += (right - middle);	//同上
        }
        while(rightPtr <= right)
        {
            temp[index++] = nums[rightPtr++];
        }
        copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);
        										//将排序结果写回nums
        return totalResult;
    }
};
```

+ 思路2：

3. [力扣148]链表排序。给定一个链表头结点，排序该链表

+ 思路：一种就是递归的插入排序做法。排序好后面的链表，然后再将首个head插入到已经排序好的链表中。时间复杂度是O(n<sup>2</sup>)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr)
            return nullptr;
        head->next = sortList(head->next);
        return insertNode(head);
    };
    ListNode* insertNode(ListNode* headNode)
    {
        if (headNode == nullptr)
            return nullptr;
        ListNode *newHead = headNode->next;
        ListNode *current = headNode;
        ListNode *currentNext = headNode->next;
        while(currentNext)
        {
            if (current->val <= headNode->val)
            {
                if (currentNext && currentNext->val > headNode->val)
                {
                    if (current == headNode)
                        return headNode;
                    headNode->next = currentNext;
                    current->next = headNode;
                    return newHead;
                }
            }
            current = current->next;
            currentNext = current->next;
        }
        if (current == headNode)
            return headNode;
        current->next = headNode;
        headNode->next = nullptr;
        return newHead;
    }
};
```

+ 思路：归并排序。使用快慢指针将链表拆分成两个子链表，分别进行归并排序，然后再利用合并链表的办法排序。这是自顶向下的归并排序，意味着空间复杂度为O(logn)；而使用自底向上的，则可以达到O(1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* findMiddleNode(ListNode* node) {
        if (node == nullptr)
            return nullptr;
        ListNode* slow = node, *fast = node;
        while(fast && fast->next && fast->next->next)
        {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
    ListNode* mergeList(ListNode* firstList, ListNode* secondList) {
        ListNode *head = new ListNode();
        ListNode *current = head;
        while(firstList && secondList)
        {
            if (firstList->val < secondList->val)
            {
                current->next = firstList;
                firstList = firstList->next;
            }
            else{
                current->next = secondList;
                secondList = secondList->next;
            }
            current = current->next;
            current->next = nullptr;
        }
        while(firstList)
        {
            current->next = firstList;
            firstList = firstList->next;
            current = current->next;
            current->next = nullptr;
        }
        while(secondList)
        {
            current->next = secondList;
            secondList = secondList->next;
            current = current->next;
            current->next = nullptr;
        }
        ListNode* temp = head;
        head = head->next;
        delete temp;
        return head;
    }
    ListNode* sortList(ListNode* head) {
        ListNode* middle = findMiddleNode(head);
        if (middle == nullptr)
            return nullptr;
        if (head->next == nullptr)
            return head;
        ListNode* temp = middle->next;
        middle->next = nullptr;
        ListNode* leftList = sortList(temp);
        ListNode* rightList = sortList(head);
        ListNode* newHead = nullptr;
        return mergeList(leftList, rightList);
    }
};
```

### [回溯]

#### 算法描述

#### 相关题目

1. 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。

   candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 

   对于给定的输入，保证和为 target 的唯一组合数少于 150 个。

+ 思路：这种组合问题，一个数既可以选，也可以不选，那么可以得到一棵树，说明可以考虑回溯法，而回溯，则常常使用深度优先。如果不选择candidates[i]，则target不变，下标移动到i + 1，如果选择candidates[i]，则target -= candidates[i]，下标不变，因为可以重复。

```c++
class Solution {
public:
    void dfs(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& combine, int idx) {
        if (idx == candidates.size()) {
            return;
        }
        if (target == 0) {
            ans.emplace_back(combine);
            return;
        }
        // 直接跳过
            dfs(candidates, target, ans, combine, idx + 1);
        // 选择当前数
        if (target - candidates[idx] >= 0) {
            
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector<vector<int>> ans;
        vector<int> combine;
        dfs(candidates, target, ans, combine, 0);
        return ans;
    }
};
```

****

2. 给定一个二维字符网格board，和一个字符串，看是否存在相邻的字符使得word在网格中

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int row = board.size();
        int coloumn = board[0].size();
        
        // 记住这种写法
        vector<vector<bool>> tick(row, vector<bool>(coloumn, false));
        for (int i = 0; i < row; ++i)
            for (int j = 0; j < coloumn; ++j)
            {
                if (hasString(board, i, j, row, coloumn, word, 0, tick))
                    return true;
            }
        return false;
    }

    bool hasString(vector<vector<char>>& board, int i, int j, int row, int coloumn, string& word, int index, vector<vector<bool>> &tick)
    {
        static vector<pair<int, int>> directions = {{1,0},{-1,0},{0,1},{0,-1}};
        if (board[i][j] != word[index])
            return false;
        tick[i][j] = true;
        if (index == word.length() - 1)
            return true;
        for(const auto &direction : directions)
        {
            int newI = i + direction.first;
            int newJ = j + direction.second;
            if (newI >= 0 && newI < row && newJ >= 0 && newJ < coloumn && !tick[newI][newJ])
            {
                if (hasString(board, newI, newJ, row, coloumn, word, index + 1, tick))
                    return true;
            }
        }
        tick[i][j] = false;
        return false;
    }
};
```

3. [力扣96,动态规划]给你一个整数n，求n个结点可以组成的结点值为1到n的二叉树的个数

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> result(n + 1, 0);
        result[0] = 1;
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= i; ++j)
            {
                result[i] += result[j - 1] * result[i - j];
            }
        }
        return result[n];
    }
};
```

4. [力扣95]给你一个整数 n ，请你生成并返回所有由 n个节点组成且节点值从1到n互不相同的不同 **二叉搜索树** 。可以按**任意顺序** 返回答案。

+ 思路1[递归]：一般二叉树的题目，可以想到使用回溯。当我们选择第i个结点作为根时，就需要得到左边1到i-1和右边i+1到n的结果，然后将结果和根组合，返回即可，思路简单，但是写起来需要注意很多地方。一个是如何定义函数的接口，一个简单的想法是，传入左右数字边界的值，例如(5, 10)，接着递归的做法一般要在函数最前面留递归出口，比如传入(5, 4)和(11, 10)的情况，还有(5, 5)这种。考虑好边界，就可以开写了
+ 思路2[动态规划]:既然有递归，那就有动态规划，我们求出长度为i的结果，其实可以通过给结点加偏差值的办法来获得，就没必要去重新求相同长度的部分，需要注意的是可能需要复制一棵二叉树，递归就行，也挺麻烦其实。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if (n == 0)
            return {};
        return makeSubTrees(1, n);
    }

    vector<TreeNode*> makeSubTrees(int left, int right)
    {
        if (left > right)
        {
            return {nullptr};
        }
        if (left == right)
            return {new TreeNode(left)};
        vector<TreeNode *> result;
        for (int i = left; i <= right; ++i)
        {
            vector<TreeNode *> leftResult = makeSubTrees(left, i - 1);
            vector<TreeNode *> rightResult = makeSubTrees(i + 1, right);
            int leftSize = leftResult.size();
            int rightSize = rightResult.size();
            for (int j = 0; j < leftSize; ++j)
                for(int k = 0; k < rightSize; ++k)
                {
                    TreeNode * currentRoot = new TreeNode(i, leftResult[j], rightResult[k]);
                    result.emplace_back(currentRoot);
                }
        }
        return result;
    }
};
```

### [排列问题]

1. 输入一个字符串，打印字符串的所有排列

* 思路：首先考虑递归办法，第0个位置有n个选择，第i个位置有n-i种选择。对于某个位置已经被选了的，就进行记录，防止再选，所以需要使用一个同样大小的标记数组。递归函数的作用就是确定第i个位置的元素。对于去重，则是如下操作，首先是对字符串排序，让相同的字符相邻。然后对于相同的字符a0，a1，仅当a0被选取时，才允许选择a1。不允许a0没选就选了a1，这样保证只有一个组合，不会重复

```c++
class Solution {
public:
    vector<string> rec;
    vector<int> vis;
    void backtrack(const string& s, int i, int n, string& perm) {
        if (i == n) {
            rec.push_back(perm);
            return;
        }//到了第n个时，说明已经获得了一个排列
        for (int j = 0; j < n; ++j) {
            if (vis[j] || (j > 0 && !vis[j - 1] && s[j - 1] == s[j])) {
                continue;
            }
            vis[j] = true;
            perm.push_back(s[j]);
            backtrack(s, i + 1, n, perm);				//也是回溯
            perm.pop_back();
            vis[j] = false;
        }
    }

    vector<string> permutation(string s) {
        int n = s.size();
        vis.resize(n);
        sort(s.begin(), s.end());
        string perm;
        backtrack(s, 0, n, perm);
        return rec;
    }
};
```

+ 思路2：先对s进行排序，然后每次获得下一个全排列即可

```c++
class Solution {
public:
    bool nextPermutation(string& s) {
        int i = s.size() - 2;
        while (i >= 0 && s[i] >= s[i + 1]) {
            i--;
        }
        if (i < 0) {
            return false;
        }//先找到一个位置，该位置的元素小于后面一个元素
        int j = s.size() - 1;
        while (j >= 0 && s[i] >= s[j]) {
            j--;
        }
        swap(s[i], s[j]);//从后面的元素中找一个最小的大于该元素的，并交换
        reverse(s.begin() + i + 1, s.end());
        //将该元素之后的进行排序，得到下一个排列
        return true;
    }

    vector<string> permutation(string s) {
        vector<string> ret;
        sort(s.begin(), s.end());//默认从小到大
        do {
            ret.push_back(s);
        } while (nextPermutation(s));
        return ret;
    }
};
```
2. 给定一个无重复的nums，求出所有排列
+ 思路：和上面一样，不过没有重复的问题。都是采用回溯法+深度优先，其实，如果每次都复制，就没必要逆向修改。

  ```c++
  class Solution {
      vector<vector<int>> res;
      int size;
      void permuteHelper(vector<int>& nums, int index)
      {
          if (index == size)
          {
              res.push_back(nums);
          }
          for (int i = index; i < size; ++i)
          {
              swap(nums[i], nums[index]);
              permuteHelper(nums, index + 1);
              swap(nums[i], nums[index]);
          }
      }
  public:
      vector<vector<int>> permute(vector<int>& nums) {
          size = nums.size();
          permuteHelper(nums, 0);
          return res;
      }
  };
  ```

  



****

### [Top-K问题]

+ 基本思路：
  + 全部排序
  + 快速排序选择
  
  ```c++
  class Solution {
      int size;
  public:
      int __quick_sort_helper(vector<int>& nums, int left, int right,int k)
      {
          int leftIter = left, rightIter = right;
          int val = nums[left];
          while(leftIter < rightIter)
          {
              while(leftIter < rightIter && nums[rightIter] <= val)
              {
                  --rightIter;
              }
              nums[leftIter] = nums[rightIter];
              while(leftIter < rightIter && nums[leftIter] > val)
              {
                  ++leftIter;
              }
              nums[rightIter] = nums[leftIter];
          }
          nums[leftIter] = val;
          if (leftIter == k - 1)
              return val;
          if (leftIter < k - 1)
              return __quick_sort_helper(nums, leftIter + 1, right, k);
          return __quick_sort_helper(nums, left, leftIter - 1, k);
      }
      int findKthLargest(vector<int>& nums, int k) {
          size = nums.size();
          return __quick_sort_helper(nums, 0, size - 1, k);
      }
  };
  ```
  
  
  
  + 使用小顶堆找最大的K个；大顶堆找最小的K个
  + 分治法
    + 数据分成N份，每份都能读取到内存里处理，找到每组的最大K个数，这时就剩N*K个数据了，再从这N\*K个数继续分治，直到能读到内存里处理，就使用前面的方式选择Top-K的处理
  + hash法
    + 使用hash去重，再看数据量大小，看能否读入内存，可以就直接排序，否则使用分治或者小顶堆

### [LIS问题]

+ 问题描述：求一个序列的最长递增子序列/最长非降子序列
+ 问题解法：
  + dp算法   O(n<sup>2</sup>)
  + <font color = "red">二分+贪心   O(nlogn)</font>

```c++
// dp法
class Solution
{
    int longestIncreasingSequence(vector<int>& nums)
    {
        int size = nums.size();
        int result = 0;
        vector<int> dp(size, 1);
        for (int i = 0; i < size; ++i)
        {
            for (int j = i - 1; j >= 0; --j)
            {
                if (dp[i] > dp[j])
                	dp[i] = max(dp[i], dp[j] + 1);	//若是非降，则改成>=
            }
            result = max(result, dp[i]);
        }
        return result;
    }
}


// 二分+贪心法
// 基本思想：对于已经得到的序列而言，它的最后一个元素越小，越有利于后续得到更长的序列，于是维护好已经得到的数组即可。
// 注意这种只适合求个数，如果要求序列，还是上面那个吧
// 以[1, 7, 3, 5, 9, 4, 8]为例
// ①[1]
// ②[1, 7]
// ③[1, 3]
// ④[1, 3, 5]
// ⑤[1, 3, 5, 9]
// ⑥[1, 3, 4, 9]
// ⑦[1, 3, 4, 8]
// 那么就是4了
class Solution
{
    int longestIncreasingSequence(vector<int>& nums)
    {
        int size = nums.size();
        int *sequenceStack = new int[size];
        int top = -1;
        for (int x : nums)
        {
            if (top == -1 || x > sequenceStack[top])
            {
                sequenceStack[++top] = x;
            }
            else
            {
                int left = 0, right = top;
                while(left <= right)
                {
                    int middle = left + ((right - left)>>1);
                    if (nums[middle] <= x)
                    {
                        left = middle + 1;
                    }
                    else
                    {
                        right = middle;
                    }
                }
            }
        }
    }
}
```

### [前缀和]

1. [力扣238]给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

   题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。

   请不要使用除法，且在 O(n) 时间复杂度内完成此题。

   + 思路：就是计算前缀和，后缀和，然后存放起来再拿来用就行了。

   ```c++
   class Solution {
   public:
       vector<int> productExceptSelf(vector<int>& nums) {
           int size = nums.size();
           vector<pair<int, int>> priorMultiplyResult(size);
           for (int i = 0; i < size; ++i)
           {
               if (i == 0)
               {
                   priorMultiplyResult[i].first = 1;
                   priorMultiplyResult[size - 1 - i].second = 1;
               }
               else
               {
                   priorMultiplyResult[i].first = priorMultiplyResult[i - 1].first * nums[i - 1];
                   priorMultiplyResult[size - 1 - i].second = priorMultiplyResult[size - i].second * nums[size - i];
               }
           }
           vector<int> result(size);
           for (int i = 0; i < size; ++i)
           {
               result[i] = priorMultiplyResult[i].first * priorMultiplyResult[i].second;
           }
           return result;
       }
   };
   ```

### [股票问题]

1. [力扣121]\[动态规划]只买一次股票求最大股票值

+ 思路：就是求最大递增子序列

  ```c++
  class Solution {
  public:
      int maxProfit(vector<int>& prices) {
          int minprice = INT_MAX, maxprofit = 0;
          for (int price : prices) {
              minprice = min(price, minprice);
              maxprofit = max(maxprofit, price - minprice);
          }
          return maxprofit;
      }
  };
  ```

2. [力扣122]\[贪心]可以多次买卖股票，且可以当天买入当天卖出

+ 思路：只要有的赚，我就赚

  ```c++
  class Solution {
  public:
      int maxProfit(vector<int>& prices) {
          int size = prices.size();
          int profit = 0;
          for (int i = 0; i < size - 1; ++i)
          {
              profit += max(0, prices[i + 1] - prices[i]);
          }
          return profit;
      }
  };
  ```


### [链表题]

1. [力扣876]找链表中点，如果是偶数个，则返回靠右的结点。

   ```c++
   class Solution {
   public:
       ListNode* middleNode(ListNode* head) {
           ListNode* slow = head;
           ListNode* fast = head;
           while(fast && fast->next)			//如果是要靠左边的那个，则写成fast && fast->next && fast->next->next
           {
               fast = fast->next->next;
               slow = slow->next;
           }
           return slow;
       }
   };
   ```

2. [力扣206]反转链表

   + 递归方法
   
   ```c++
   /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     ListNode *next;
    *     ListNode() : val(0), next(nullptr) {}
    *     ListNode(int x) : val(x), next(nullptr) {}
    *     ListNode(int x, ListNode *next) : val(x), next(next) {}
    * };
    */
   class Solution {
   public:
       ListNode* reverseList(ListNode* head) {
           if (!head || head->next == nullptr)			//递归出口不要漏掉只有一个结点的情况
               return head;
           ListNode* currentNext = head->next;
           ListNode* newHead = reverseList(head->next);
           currentNext->next = head;
           head->next = nullptr;
           return newHead;
       }
   };
   ```
   
   + 迭代方法
   
   ```c++
   /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     ListNode *next;
    *     ListNode() : val(0), next(nullptr) {}
    *     ListNode(int x) : val(x), next(nullptr) {}
    *     ListNode(int x, ListNode *next) : val(x), next(next) {}
    * };
    */
   class Solution {
   public:
       ListNode* reverseList(ListNode* head) {
           ListNode* temp = nullptr;
           while(head)
           {
               ListNode* nextHead = head->next;
               head->next = temp;
               temp = head;
               head = nextHead;
           }
           return temp;
       }
   };
   ```

3. [力扣143]重排链表

   如[1,2,3,4,5]排成[1,5,2,4,3]

+ 思路：简单一看，可以发现，就是将左半边和右半边的反转链表一个个元素接起来。所以可以先找到链表中点，然后再将后半反转，再依次连接。

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  public:
      ListNode * reverseList(ListNode* head)
      {
          ListNode* prior = nullptr;
          while(head)
          {
              ListNode* tempNext = head->next;
              head->next = prior;
              prior = head;
              head = tempNext;
          }
          return prior;
      }
  
      ListNode * findMiddle(ListNode* head)
      {
          ListNode* fast = head, *slow = head;
          while(fast && fast->next && fast->next->next)
          {
              fast = fast->next->next;
              slow = slow->next;
          }
          return slow;
      }
  
      void reorderList(ListNode* head) {
          ListNode* middleNode = findMiddle(head);
          ListNode* reverseListHead = reverseList(middleNode->next);
          middleNode->next = nullptr;
          while(head && reverseListHead)
          {
              ListNode* headNext = head->next;
              ListNode* reverserNext = reverseListHead->next;
              head->next = reverseListHead;
              reverseListHead->next = headNext;
              head = headNext;
              reverseListHead = reverserNext;
          }
      }
  };
  ```

4. [力扣141] 判断链表是否有环

+ 思路：没啥好讲的，快慢指针。与此相关的一个问题是，如果存在环，如何得到环的部分的长度呢？答案是在判断到链表有环时，快慢指针正好相遇，然后让他们再次相遇，记录这期间慢指针走过的个数，就是环的长度。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* slowNode = head;
        ListNode* fastNode = head;
        while(fastNode != nullptr)
        {
            fastNode = fastNode->next;
            if (fastNode != nullptr)
                fastNode = fastNode->next;
            else break;
            slowNode = slowNode->next;
            if (fastNode == slowNode)
                return true;
        }
        return false;
    }
};
```

5. [力扣142]环形链表2  已知一个环形链表，要求环形链表中形成环的部分的首个结点

+ 思路1【快慢指针】：上一个题目，我们使用快慢指针的做法，当两指针相遇时，说明是环状链表。接下来好好考虑一下，设环状链表由非环部分a和环部分d组成，其中快慢指针相遇时，慢指针走到了环部分，设它走了x长度，在环部分中走了b步，则x = a + b；此时快指针应该走了2x步，其中2x = a + md + b，这样，我们可以得到md = x = a + b，则a = md - b，说明如果另设一个指针从开头继续走，和慢指针同步走，那么当该指针走了a步时，慢指针将走m - 1圈多(d - b)步，既然之前在环中走了b步，说明此时必然是和该指针在环的开头相遇。
+ 时间复杂度O(n)

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while (fast != nullptr) {
            slow = slow->next;
            if (fast->next == nullptr) {
                return nullptr;
            }
            fast = fast->next->next;
            if (fast == slow) {
                ListNode *ptr = head;
                while (ptr != slow) {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```

+ 思路2【哈希】简单讲就是把原来的链表的每个结点存放到哈希表里，如果结点在哈希表里头已经有了，说明是环的一部分。
+ 时间复杂度O(n)，空间也是

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode *> visited;
        while (head != nullptr) {
            if (visited.count(head)) {
                return head;
            }
            visited.insert(head);
            head = head->next;
        }
        return nullptr;
    }
};
```

6. [力扣160]相交链表

+ 思路1：一种做法是哈希，遍历结点并加入到unordered_set，再遍历另一个表，如果发现结点在set里面有，就返回该结点；最后返回nullptr。
+ 思路2：双指针，nodeIterA遍历链表A，nodeIterB遍历链表B。假设有相交部分，且设相交部分长度为c，A的前半长为a，B的为b。
  + 如果a == b，则nodeIterA和 nodeIterB同时移动的时候就能碰到这个结点。
  + 如果a ! = b，则只要谁遍历到了nullptr，就换到另一个链表的头结点上继续遍历。
    + 这样，nodeIter们都会在走了a + c + b的长度以后相遇
  + 而当没有交集的时候，它们都会遍历到a + b + 2c，最后的情况下，两者都变为nullptr

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == nullptr || headB == nullptr)				//先剪枝
            return nullptr;
        ListNode* nodeIterA = headA;
        ListNode* nodeIterB = headB;
        while(nodeIterA != nodeIterB)
        {
            nodeIterA = nodeIterA == nullptr?headB:nodeIterA->next;
            nodeIterB = nodeIterB == nullptr?headA:nodeIterB->next;
        }
        return nodeIterA;
    }
};
```

7. [力扣25]K个一组，反转链表。不足k个的，就不反转。

+ 思路：比较麻烦的题还是递归解法。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (head == nullptr)								//递归出口
            return nullptr;
        int temp = k;
        ListNode* current = head;
        while(current && temp != 0)							//别把temp--和current写一起作为判断，否则很可能导致temp有时候减，有时候不减
        {
            current = current->next;
            temp--;
        }
        if (temp != 0)
            return head;									//不足k个，就不反转，直接返回头结点
        ListNode* nextListHead = reverseKGroup(current, k); //否则，存储下一个部分的结果的头结点
        ListNode* currentTail = head;						//记录尾结点
        ListNode* prior = nullptr, *currentNodeIter = head;
        while(k--)
        {
            ListNode* tempNode = currentNodeIter->next;
            currentNodeIter->next = prior;
            prior = currentNodeIter;
            currentNodeIter = tempNode;
        }
        currentTail->next = nextListHead;					//进行k个翻转，然后把尾结点和nextListHead连起来
        return prior;
    }
};
```

