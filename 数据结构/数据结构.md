# 数据结构

## 1. 红黑树

### 1.1 红黑树的性质

#### 1.1.1 基本性质

+ 每个结点有红色或者黑色
+ 根节点是黑色，叶子结点也是黑色，这里的叶子结点指nil结点
+ 如果一个结点是红色的，那么它的子结点一定是黑色的
+ 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（通常记结点x到一个叶结点的一条简单路径上除x结点以外的黑色结点的个数为黑高）

注：

1. 正是由于颜色的限制，使得没有一条路径会比其它路径长出2倍，使得其近似平衡。
2. 通常会将nil结点设置成一个单独的哨兵结点，对于为空的子结点，就都指向它，而不是都设置新的nil结点。这样，nil结点就是黑色的

#### 1.1.2 一些引理

1. 一棵有n个内部结点的红黑树的高度至多为2lg(n + 1)
   + 证明时，证明逆否命题即可。即高度为高度为h的红黑树，它的包含的内部结点个数至少为 2<sup>bh(x)</sup>-1个，而bh(x)自然至少是h/2
   + 这个引理也说明在使用红黑树做查找时的时间复杂度是O(lgn)

### 1.2 红黑树的旋转

+ 和二叉搜索树的旋转一样，也是左旋和右旋，旋转方式也一样

  ![](pictures/1.png)

  ![](pictures/2.png)

  ![](pictures/3.png)

### 1.3 插入结点

+ 二叉搜索树插入一个结点的时间是O(lgn)，这其中就包括了查找到相对应位置以及做的调整工作；同样地，既然红黑树的search复杂度也是O(lgn)那么自然也可以在O(lgn)时间内插入结点
+ 插入步骤：
  + 插入的结点先被置为红色
  + 当成二叉查找树来将结点插入
  + 旋转或者着色，使得它重新变成一棵红黑树

+ 旋转和着色的情况

  1. 父节点是红色，叔叔节点也是红色

     将父结点和叔叔结点同设为黑色，同时把祖父结点设置为红色；之后将**祖父结点**设置为当前结点

  2. 父节点是红色，叔叔节点是黑色

     如果父结点是祖父结点的左孩子，就右旋；如果父结点是祖父结点的右孩子，就左旋。然后**将这个父结点设置成当前结点**

+ 时间复杂度
  + 高度是O(lgn)，最多对每层都操作，故复杂度就是O(lgn)

### 1.4 删除结点

+ 删除步骤：

  + 将红黑树当普通的二叉查找树删除结点

    + 结点若没有儿子，则直接删除，置父结点的对应位置为nil
    + 结点只有一个儿子，则直接删除之，并用子结点代替它
    + 结点有两个儿子，则先找出后继节点，将后继节点的val赋值到该结点，再删除没用的后继结点。自然，后继结点要么只有一个儿子，要么没儿子，就变成了上面两种情况了。这个后继结点要求必须大于等于原结点的左子树的所有结点，所以要么选左子树的最大结点，要么右子树的最小结点，一般前者。

  + 通过旋转和重新着色来修改它，使得重新变成一棵红黑树

    + 首先考虑可能遇到的情况数，结点本身可能无孩子，有一个孩子，有两个孩子；还有两种颜色，总共6种情况

      1. 结点无孩子 + 红色

         直接删就行，不会有影响

      2. <font color = "red">结点无孩子 + 黑色</font>

         这个情况最复杂，需要考虑兄弟结点brother和父结点father的颜色情况。

         + brother为黑色时

           + 如果brother拥有一个方向一致的红色son

             (所谓方向一致，是指brother为father的左子结点，son也为brother的左子结点；或者brother为father的右子结点，son也为brother的右子结点。)

             ![](pictures/6.png)

           + 如果brother拥有一个方向不一致的红色son

             ![](pictures/7.png)

           + 如果brother无红色son

             + 如果father是红色的，则如下处置

             ![](pictures/8.png)

             + 如果father是黑色的，则重新着色，将游离的黑色权值存到father（此时father的黑色权重为2），将father作为新的结点进行情形判断，遇到上面的情况，则进行相应的调整，完成删除操作；如果没有，则结点一直上溯，直到根结点存储额外的黑色，此时将该额外的黑色扔掉，即完成了删除操作

               ![](pictures/9.png)

         + brother为红色时

           此时father只能为黑色

           ![](pictures/10.png)

           做上述操作后，原来brother的son就变成了新的brother，然后回到前面的情况了

      3. 结点有一个孩子 + 红色

         这是不可能的，红色的结点不可能只有一个孩子，不然以该结点为root的子树就不符合红黑树的性质

         ![](pictures/5.png)

      4. 结点有一个孩子 + 黑色

         说明结点的孩子的颜色必然是红色的，如果是黑色的，它必然导致黑高不相等，这时，删除的时候就是把红色的孩子换上来，然后把替换上来的孩子的颜色改成黑色

         ![](pictures/4.png)

      5. 结点有两个孩子 + 红色

         实际就是删除替换结点，这可以转换成上面的4种情况的某种

      6. 结点有两个孩子 + 黑色

         同5

